/*
 Navicat Premium Data Transfer

 Source Server         : loafMysql
 Source Server Type    : MySQL
 Source Server Version : 50734
 Source Host           : 192.168.145.132:3306
 Source Schema         : loafblog_blog

 Target Server Type    : MySQL
 Target Server Version : 50734
 File Encoding         : 65001

 Date: 04/05/2023 16:48:43
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '博客id',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `tid` int(11) NULL DEFAULT NULL COMMENT '标签id',
  `cid` int(11) NULL DEFAULT NULL COMMENT '分类id',
  `mdContent` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT 'md格式内容',
  `htmlContent` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT 'html格式内容',
  `summary` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '梗概',
  `image` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '博客封面',
  `publishDate` datetime(0) NULL DEFAULT NULL COMMENT '发布时间',
  `isOriginal` tinyint(4) NOT NULL DEFAULT 0 COMMENT '是否原创【0-否,1-是】',
  `isComment` tinyint(4) NOT NULL DEFAULT 0 COMMENT '是否评论【0-否,1-是】',
  `number` int(11) NULL DEFAULT NULL COMMENT '文章字数',
  `state` int(4) NOT NULL DEFAULT 0 COMMENT '状态【0-存在,1-已删除】',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博客内容和属性' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (31, 'Spring Cloud学习笔记', 3, 2, '## Hystrix\n\n断路器\n\n通过继承方式实现同步掉用和异步调用(入队再执行)\n\n```java\n@RestController\npublic class HelloController {\n    @Autowired\n    RestTemplate restTemplate;\n    @Autowired\n    HelloService helloService;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return helloService.hello();\n    }\n\n    @GetMapping(\"/hello2\")\n    public void hello2() {\n        HelloCommand helloCommand = new HelloCommand(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"thciwei\")), restTemplate);\n        // helloCommand.run(); 直接调用run()相当于手写一个线程再调用线程的run方法，这种方式使Hystrix的一套东西无法生效\n        /**\n         * 执行的两种方法\n         */\n        String execute = helloCommand.execute();\n        System.out.println(execute);\n        //new一个直接执行\n        HelloCommand helloCommand2 = new HelloCommand(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"thciwei\")), restTemplate);\n        try {\n            Future<String> queue = helloCommand2.queue();\n            String s = queue.get();\n            System.out.println(s);\n            //先入队，后执行\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n```\n\n\n\nctrl+o 查看HelloCommand继承的方法\n\n```java\n/**\n * 请求失败的回调\n * @return\n */\n@Override\nprotected String getFallback() {\n    return \"error-extends\";\n}\n```\n\n访问localhost:3000/hello2，关闭provider1114，打印出1113信息和error-extend，等待一段时间再次访问则只会出现1113信息\n\n### 异常处理\n\nhelloservice抛出异常服务降级\n\n```java\n@HystrixCommand(fallbackMethod = \"error\")\npublic String hello() {\n    /**\n     * 异常处理 添加一个异常测试\n     */\n    int i=1/0;\n\n    return restTemplate.getForObject(\"http://provider/hello\", String.class);\n}\n```\n\n\n\n```java\npublic String error(Throwable t) {\n    /**\n     * 大 Boos throwable 异常\n     */\n    return \"error\"+ t.getMessage();\n}\n```\n\n访问localhost:3000/hello，显示异常 error/ by zero\n\n\n\nHelloCommand中\n\ngetExecutionException().getMessage()为自带获取异常方法\n\n```java\n@Override\nprotected String run() throws Exception {\n    int i=1/0;\n    return restTemplate.getForObject(\"http://provider/hello\",String.class);\n}\n```\n\n```java\n@Override\nprotected String getFallback() {\n    return \"error-extends\"+getExecutionException().getMessage();\n}\n```\n\n那么如何实现抛出异常服务不降级\n\n\n\n### 请求合并\n\n在provider提供一个请求的接口来解决consumer频繁调用 provider同一个接口的问题，比如通过id请求多个User数据，使用commons中的User实体\n\n```java\n@RestController\npublic class UserController {\n    @GetMapping(\"/user/{ids}\")//假设 consumer 传过来的多个id格式是 1，2，3，4....\n    public List<User> getUserById(@PathVariable String ids) {\n        String[] split = ids.split(\",\");\n        List<User> users = new ArrayList<>();\n        for (String s : split) {\n            User user = new User();\n            user.setId(Integer.parseInt(s));\n            users.add(user);\n        }\n        return users;\n    }\n}\n```\n\n创建UserService发送请求\n\n```java\n@Service\npublic class UserService {\n    @Autowired\n    RestTemplate restTemplate;\n\n    public List<User> getUserByIds(List<Integer> ids) {\n        User[] users = restTemplate.getForObject(\"http://provider/user/{1}\", User[].class, StringUtils.join(ids, \",\"));\n        return Arrays.asList(users);\n\n    }\n\n}\n```\n\nhystrix中创建UserBatchCommand 相当于之前的HelloCommand\n\n```java\npublic class UserBatchCommand extends HystrixCommand<List<User>> {\n    private List<Integer> ids;\n    private UserService userService;\n\n    public UserBatchCommand(Setter setter, List<Integer> ids, UserService userService) {\n        super(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"batchCmd\")).andCommandKey(HystrixCommandKey.Factory.asKey(\"batchKey\")));\n        this.ids = ids;\n        this.userService = userService;\n    }\n\n    @Override\n    protected List<User> run() throws Exception {\n        return userService.getUserByIds(ids);\n    }\n}\n```\n\n**请求合并方法**\n\n```java\npublic class UserCollapseCommand extends HystrixCollapser<List<User>, User, Integer> {\n    private UserService userService;\n    private Integer id;\n/**\n*构造器中给setter设置延迟时间，200毫秒后不再等待\n**/\n    public UserCollapseCommand(UserService userService, Integer id) {\n        super(HystrixCollapser.Setter.withCollapserKey(HystrixCollapserKey.Factory.asKey(\"UserCollapseCommand\")).andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(200)));\n        this.userService = userService;\n        this.id = id;\n    }\n\n    @Override\n    public Integer getRequestArgument() {\n        return id;\n    }\n\n    /**\n     * 请求结果合并方法\n     *\n     * @param collection\n     */\n    @Override\n    protected HystrixCommand<List<User>> createCommand(Collection<CollapsedRequest<User, Integer>> collection) {\n        ArrayList<Integer> ids = new ArrayList<>(collection.size());\n        for (CollapsedRequest<User, Integer> userIntegerCollapsedRequest : collection) {\n            ids.add(userIntegerCollapsedRequest.getArgument());\n        }\n        return new UserBatchCommand(ids, userService);\n    }\n\n    /**\n     * 请求结果分发\n     *\n     * @param users\n     * @param collection\n     */\n    @Override\n    protected void mapResponseToRequests(List<User> users, Collection<CollapsedRequest<User, Integer>> collection) {\n        int count = 0;\n        for (CollapsedRequest<User, Integer> request : collection) {\n            request.setResponse(users.get(count++));\n        }\n    }\n}\n```\n\n\n\n\n\n```java\n@GetMapping(\"/hello5\")\npublic void hello5() throws ExecutionException, InterruptedException {\n    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();\n    UserCollapseCommand cmd1 = new UserCollapseCommand(userService, 99);\n    UserCollapseCommand cmd2 = new UserCollapseCommand(userService, 98);\n    UserCollapseCommand cmd3 = new UserCollapseCommand(userService, 97);\n    UserCollapseCommand cmd4 = new UserCollapseCommand(userService, 96);\n    Future<User> queue1 = cmd1.queue();\n    Future<User> queue2 = cmd2.queue();\n    Future<User> queue3 = cmd3.queue();\n    Future<User> queue4 = cmd4.queue();\n    User user1 = queue1.get();\n    User user2 = queue2.get();\n    User user3 = queue3.get();\n    User user3 = queue4.get();\n    System.out.println(user1);\n    System.out.println(user2);\n    System.out.println(user3);\n    System.out.println(user4);\n\n    ctx.close();\n\n}\n```\n\nprovider收到一个请求 99 98 97 96\n\nhystrix收到分发的数据\n\n```java\nUser{id=99, username=\'null\', password=\'null\'}\nUser{id=98, username=\'null\', password=\'null\'}\nUser{id=97, username=\'null\', password=\'null\'}\nUser{id=96, username=\'null\', password=\'null\'}\n```\n\n**睡眠测试**\n\n```java\n@GetMapping(\"/hello5\")\npublic void hello5() throws ExecutionException, InterruptedException {\n    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();\n    UserCollapseCommand cmd1 = new UserCollapseCommand(userService, 99);\n    UserCollapseCommand cmd2 = new UserCollapseCommand(userService, 98);\n    UserCollapseCommand cmd3 = new UserCollapseCommand(userService, 97);\n    Future<User> queue1 = cmd1.queue();\n    Future<User> queue2 = cmd2.queue();\n    Future<User> queue3 = cmd3.queue();\n    User user1 = queue1.get();\n    User user2 = queue2.get();\n    User user3 = queue3.get();\n    System.out.println(user1);\n    System.out.println(user2);\n    System.out.println(user3);\n    Thread.sleep(2000);\n    UserCollapseCommand cmd4 = new UserCollapseCommand(userService, 96);\n    Future<User> queue4 = cmd4.queue();\n    User user4 = queue4.get();\n    System.out.println(user4);\n    ctx.close();\n\n}\n```\n\nprovider收到两个请求\n\n```\n97,98,99\n96\n```\n\nhystrix打印两个数据\n\n```\nUser{id=99, username=\'null\', password=\'null\'}\nUser{id=98, username=\'null\', password=\'null\'}\nUser{id=97, username=\'null\', password=\'null\'}\n--wait\nUser{id=96, username=\'null\', password=\'null\'}\n```\n\n\n\n**注解实现合并**\n\n@HystrixCollapser 确定方法和参数 key-value\n\n@HystrixCommand确认方法\n\n```java\n@Service\npublic class UserService {\n    @Autowired\n    RestTemplate restTemplate;\n\n    @HystrixCollapser(batchMethod = \"getUserByIds\", collapserProperties = {@HystrixProperty(name = \"timerDelayInMilliseconds\", value = \"200\")})\n    public Future<User> getUserById(Integer id) {\n        return null;\n    }\n\n    @HystrixCommand\n    public List<User> getUserByIds(List<Integer> ids) {\n        User[] users = restTemplate.getForObject(\"http://provider/user/{1}\", User[].class, StringUtils.join(ids, \",\"));\n        return Arrays.asList(users);\n    }\n}\n```\n\n测试\n\n```java\n@GetMapping(\"/hello6\")\npublic void hello6() throws ExecutionException, InterruptedException {\n    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();\n    Future<User> q1 = userService.getUserById(95);\n    Future<User> q2 = userService.getUserById(94);\n    Future<User> q3 = userService.getUserById(94);\n    User u1 = q1.get();\n    User u2 = q2.get();\n    User u3 = q3.get();\n    System.out.println(u1);\n    System.out.println(u2);\n    System.out.println(u3);\n    Thread.sleep(2000);\n    Future<User> q4 = userService.getUserById(93);\n    User u4 = q4.get();\n    System.out.println(u4);\n    ctx.close();\n\n}\n```\n\n\n\n## OpenFeign\n\n数据传输，“省去”RestTemplate\n\n\n\n熔断降级测试时，需关闭provider后访问 [localhost:4000/hello]() 方可出现error，服务降级的配置生效\n\n\n\n\n\n## resilience4j\n\n断路器\n\n\n\n### 策略配置\n\n— 表示数组\n\n```yaml\nresilience4j:\n  retry:\n    retry-aspect-order: 399  # retry优先级 默认高于限流和断路器,数字越小优先级越高\n    backends: #配置不同的策略\n      retryA:\n        maxRetryAttempt: 5 # 重试次数\n        waitDuration: 500 # 重试等待时间\n        exponentialBackoffMultiplier: 1.1 #间隔乘数\n        retryExceptions: # 异常配置为一个数组\n          - java.lang.RuntimeException\n  circuitbreaker:\n    instances:\n      cbA:\n        ringBufferSizeInClosedState: 5\n        ringBufferSizeInOpenState: 3\n        waitInterval: 5000  # 断路器从open切换到 half open的时间间隔\n        recordException:\n          - org.springframework.web.client.HttpServerErrorException\n    circuit-breaker-aspect-order: 398\nspring:\n  application:\n    name: resilience4j\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nserver:\n  port: 5000\n```\n\n### 熔断降级\n\n```java\n@Service\n@CircuitBreaker(name = \"cbA\", fallbackMethod = \"error\") //断路器\npublic class HelloService {\n    @Autowired\n    RestTemplate restTemplate;\n    public String hello() {\n        return restTemplate.getForObject(\"http://localhost:1113/hello\", String.class);\n    }\n\n    public String error() {\n        return \"error\";\n    }\n}\n```\n\n报错分析\n\n```\njava.lang.NoSuchMethodException: class java.lang.String class com.thciwei.resilience4j2.HelloService.error(,class java.lang.Throwable)\n```\n\n结合最后括号中的话可知，error方法缺少异常信息Boos ->Throwable参数\n\n```java\npublic String error(Throwable t) {\n    return \"error\" + t.getMessage();\n}\n```\n\n### 模拟限流\n\n因为限流是生效在客户端的，所以provider也要配置，反复刷新web页面，因为每秒只能处理一个请求，请求过多时发生熔断降级\n\n```yaml\nspring:\n  application:\n    name: provider\nserver:\n  port: 1113\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nresilience4j:\n  ratelimiter:\n   limiters:\n    rlA:  # 每秒钟处理一个请求、刷新周期、冷却时间(刷新后的冷却时间)\n     limit-for-period: 1\n     limit-refresh-period: 1s\n     timeout-duration: 1s\n```\n\n```java\n@Service\n@CircuitBreaker(name = \"cbA\", fallbackMethod = \"error\") //断路器\npublic class HelloService {\n    @Autowired\n    RestTemplate restTemplate;\n\n    public String hello() {\n        //使用循环模拟多请求\n        for (int i = 0; i < 5; i++) {\n            restTemplate.getForObject(\"http://localhost:1113/hello\", String.class);\n        }\n        return \"success\";\n    }\n\n    public String error(Throwable t) {\n        return \"error\" + t.getMessage();\n    }\n}\n```\n\n## 服务监控\n\nPrometheus\n\nGrafana \n\n推荐文章：https://urlify.cn/fua2aa\n\n```shell\n安装命令：\nrpm -ivh grafana-6.7.4-1.x86_64.rpm \n查看安装：\nrpm -q grafana\n卸载：\nrpm -e grafana\n启动和停止命令：\nsystemctl start grafana-server\nsystemctl stop grafana-server\n```\n\n\n\n\n\n## Gateway\n\n网关，以多种过滤器实现\n\n测试接口： [httpbin.org/get](http://httpbin.org/get)\n\n\n\n配置文件\n\nGateway实现对provider的代理\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: thciwei_route\n          uri: http://httpbin.org\n          predicates:\n            - Path=/get\n      discovery:\n        locator:\n          enabled: true #开启自动代理\n  application:\n    name: gateway\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nlogging:\n  level:\n    org.springframework.cloud.gateway: debug\n```\n\n访问 [localhost:8080/PROVIDER/hello](http://localhost:8080/PROVIDER/hello)\n\n查看eureka注册中心得知，provider需要大写\n\n### predicates\n\npredicates路径匹配有多种方式\n\n使用postman测试各种匹配\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: thciwei_route\n          uri: http://httpbin.org\n          predicates:\n            - After=2021-01-01T01:01:01+08:00[Asia/Shanghai] #转发\n            - After=2022-01-01T01:01:01+08:00[Asia/Shanghai] #404不转发\n            - Before=\n            - Between= \n            - Method=GET #只转发get请求\n            - Path=/2019/0612/{segments} \n            - Query=name\n            - Query=name,java.* #key为name，value中需要含有java字样，否则不转发\n```\n\n- Path=/2019/0612/{segments} 如 http://localhost:8080/2019/0612/git-install.html\n\n- Query=name如 http://localhost:8080/get?name=javaboy\n\n- Query=name,java.*如 http://localhost:8080/get?name=javboy\n\n**匹配方式可以组合使用，如果多个匹配方式，优先选择第一个被匹配上的方式作为标准**\n\n### filter\n\nhello2是provider中IUserService的一个带参数的接口，且要求必须带有参数name\n\n```java\n--  IUserService\n@GetMapping(\"/hello2\")\n    String hello2(@RequestParam(\"name\") String name);\n-- HelloController\n@Override\npublic String hello2(String name) {\n    System.out.println(new Date() + \">>>\" + name);\n    return \"hello2:\" + name;\n}\n```\n\nlb是loadBanlanced...，转发到provider时自动负载均衡，AddRequestParameter可以在转发时自动帮你来添加参数 name=thciwei\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: thciwei_route\n          uri: lb://provider\n          filters:\n            - AddRequestParameter=name,thciwei\n          predicates:\n            - Method=Get\n      discovery:\n        locator:\n          enabled: true #开启自动代理\n  application:\n    name: gateway\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nlogging:\n  level:\n    org.springframework.cloud.gateway: debug\n```\n\n这里访问 [localhost:8080/hello2](http://localhost:8080/hello2) 即可，直接访问 [localhost:1113/hello2 ](http://localhost:1113/hello2)不可以，访问 [localhost:8080/PROVIDER/hello2](http://localhost:8080/PROVIDER/hello2) 也没有作用，一切以routes中uri 的配置为准\n\n或者url请求中含有某些字段，则指定跳转页面，[localhost:88?url=qq](http://localhost:88?url=qq)\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n        - id: baidu_route\n          uri: https://wwww.baidu.com\n          predicates:\n            - Query=url,baidu\n        - id: qq_route\n          uri: https://www.qq.com\n          predicates:\n            - Query=url,qq\n```\n\n## Config\n\n分布式配置管理中心\n\n### git上传\n\nGitHub创建configRepo仓库，通过提示的指令上传文件\n\n本地准备好相应的配置文件，提交到github https://github.com/thciwei/configRepo/tree/master/client\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4lwbflkj31du046dhr.jpg)\n\n内容分别为 thciwei=dev,thciwei=prod,thciwei=test\n\n运行config后访问 [localhost:8081/client1/dev/master](http://localhost:8081/client1/dev/master)\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4m5occhj316k01xgnu.jpg)\n\nD:/temp1/config-repo-6314996172738589608/client1是config帮我们克隆到本地的一份文件，下次读取直接在本地读取\n\nweb页面可以通过 [localhost:8081/client1-prod.yml](http://localhost:8081/client1-prod.yml)、[localhost:8081/client1-prod.properties](http://localhost:8081/client1-prod.properties) 的方式访问到文件内容\n\n修改文件内容，重新提交到GitHub\n\n```git\ngit add .\ngit commit -m \"first add\"\ngit push\npush失败时可以采用 git push -f\n```\n\n刷新web页面即可显示最新的内容\n\n在 client中新建bootstrap.yml抢先在application.yml前加载\n\n```yaml\n#config下三行配置对应着config-server的 {application} {profile} {label} 的占位符\nspring:\n  application:\n    name: client1\n  cloud:\n    config:\n      profile: dev\n      label: master\n      uri: http://localhost:8081\nserver:\n  port: 8082\n```\n\n创建HelloController读取文件\n\n```java\npackage com.thciwei.configclient;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n    @Value(\"${thciwei}\")\n    String thciwei;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return thciwei;\n    }\n}\n```\n\n访问 [localhost:8082/hello](http://localhost:8082/hello) ,显示内容 dev\n\n### 密码加密\n\n下载不限制长度的 jce https://www.oracle.com/java/technologies/javase-jce8-downloads.html，解压拷贝jar包到C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\security\n\n存储时添加{cipher}前缀，否则会认定为普通字符串\n\n```properties\nthciwei={cipher}73769b7b0b414540bd97c1135ea13a3668b577347e51f30ba77c157cde85e0c3\n```\n\nconfig-server中bootstrap.yml需要配置密钥\n\n```yaml\n#密钥\nencrypt:\n  key: thciwei\n```\n\n将文件添加密文标识后，访问接口仍然不能解密，这里涉及配置是否能及时感知的问题，后面可以用消息队列等方法解决，暂时只能重启client服务后再次访问接口\n\nconfig-server读取这些资源\n\n```xml\n<build>\n    <resources>\n        <resource>\n            <directory>src/main/resources</directory>\n            <includes>\n                <include>**/*.yml</include>\n                <include>**/*.keystore</include>\n            </includes>\n        </resource>\n    </resources>\n</build>\n```\n\n\n\n### 安全管理\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n    <version>2.5.0</version>\n</dependency>\n```\n\n添加完依赖接口就会自动被spring-security保护起来了，使用user和密码（控制台获取）登录后访问[localhost:8081/client1/dev](http://localhost:8081/client1/dev) ，此时启动config-client便会报错，因为失去了凭证\n\n### 服务化\n\nconfig-client和config-server需要添加spring-security的依赖，因为之前的**keystore会造成冲突**，这里换成 jks，并更换掉alias、username和password\n\n```shell\n keytool -genkeypair -alias mytestkey -keyalg RSA -keypass 111111 -keystore D:\\javabootList\\config-service.jks -storepass 111111\n```\n\nconfig-server资源读取\n\n```xml\n<include>**/*.jks</include>\n```\n\ncongfig-server/bootstrap.yml\n\n```yaml\n#密钥\n#encrypt:\n#  key: thciwei\nencrypt:\n  key-store:\n    location:\n     classpath: config-service.jks\n    password: 111111\n    secret: 1111111\n    alias: mytestkey\nspring:\n  security:\n    user:\n     name: thciwei\n     password: thciwei\n```\n\n\n\n配置eureka注册时，config-server的配置可以放在application.yml，但是config-client的配置需要放在bootstrap.yml中\n\nconfig-server/application.yml\n\n```yaml\nspring:\n  application:\n    name: config-server\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/thciwei/configRepo.git\n          search-paths: {application}  #动态，如果报错可换回client1\n          username:\n          password:\nserver:\n  port: 8081\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\n```\n\nclient/bootstrap.yml\n\n```yaml\nspring:\n  application:\n    name: client1\n  cloud:\n    config:\n      profile: test\n      label: master\n      #uri: http://localhost:8081\n      username: thciwei\n      password: thciwei\n      #开启服务 eureka获取 config-server 的功能\n      discovery:\n        enabled: true\n        service-id: config-server #配置 config-server 名称\nserver:\n  port: 8082\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\n```\n\n\n\n### 动态刷新\n\n生产中动态刷新还是要配合消息中间件的，这里添加actuator依赖通过调用的接口方式手动进行刷新\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n对应需访问的接口类如HelloController**添加**@RefreshScope注解\n\nconfig-client\\bootstrap.yml添加对端点的自动刷新配置\n\n```yaml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: refresh\n```\n\n更改configRepo中test文件的内容，然后用git提交到GitHub，使用postman对接口 [localhost:8082/actuator/refresh](http://localhost:8082/actuator/refresh)  发送post请求刷新，再次访问 [localhost:8082/hello](http://localhost:8082/hello) 获得更新后的数据\n\n重试retry\n\n通过添加aop和spring-retry的依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.retry</groupId>\n    <artifactId>spring-retry</artifactId>\n    <version>1.3.1</version>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n    <version>2.2.7.RELEASE</version>\n</dependency>\n```\n\n在bootstr.yml配置retry\n\n```yaml\nspring:\n  application:\n    name: client1\n  cloud:\n    config:\n      profile: test\n      label: master\n      #uri: http://localhost:8081\n      username: thciwei\n      password: thciwei\n      #开启服务 eureka获取 config-server 的功能\n      discovery:\n        enabled: true\n        service-id: config-server #配置 config-server 名称\n      fail-fast: true # 开启快速响应\n      retry:\n        initial-interval: 1000 #请求重试初始时间间隔 \n        max-attempts: 6 #最大重试次数\n        multiplier: 1.1 #重试时间乘数\n        max-interval: 2000 #最大时间间隔\n```\n\n开启快速响应的目的，在config-server加载不到数据时就解决问题，否则就要等到HellController时再抛出错误，这样是不合理的\n\n通过注释掉username和password重启client可以测试错误的抛出和重试\n\n\n\n## Bus\n\n消息总线\n\nconfig-server\\bootstrap.yml\n\n```yaml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: bus-refresh\n```\n\n修改configRepo中test文件，使用postman对config-server的bus-refresh接口发送post请求，server在bus上把指令传给rabbitmq，会通过rabbitmq把刷新指令传递到config的每一个client，实现自动更新文件，最后访问 [localhost:8082/hello](http://localhost:8082/hello)\n\n因为springsecurity中配置的.httpBasic()，type选择**basic auth**，用户名密码使用yml配置，请求无响应表示成功\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4mnn386j31cx0a1q5p.jpg)\n\nserver中需要bus和actuator的依赖，client需要bus的依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n* 多个刷新\n\njava -jar启动8082和8083两个服务，只刷新某一个client服务则添加service-id http://localhost:8081/actuator/bus-refresh/client1:8082\n\n\n\n## Stream\n\n表示stream连接上了rabbitmq\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4myq4qlj315i01u76u.jpg)\n\n\n\n使用rabbitmq发送消息\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4n6qo70j30xg0kawim.jpg)\n\n控制台可检查收到的消息\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4ni9sdoj316400tmyd.jpg)\n\n\n\n```yaml\nspring:\n  rabbitmq:\n    username: guest\n    password: guest\n    host: localhost\n    port: 5672\n  cloud:\n    stream:\n      bindings:\n        thciwei-input: \n          destination: thciwei-topic #destination相同便能保证收发消息\n          group: g1 # 消息分组\n        thciwei-output:\n          destination: thciwei-topic\n          group: g1 # 消息分组\n```\n\n* 消息分组\n\n分组后消息只能被一个实例所消费，创建一个消费者集群\n\n```shell\njava -jar stream-0.0.1-SNAPSHOT.jar --server.port=8080\njava -jar stream-0.0.1-SNAPSHOT.jar --server.port=8081\n```\n\n在控制台右击clear buffer后，访问hello接口 [localhost:8080/hello](http://localhost:8080/hello)，消息只会被其中一个实例接收，访问两次接口结果更直观\n\n* 消息分区\n\n```yaml\nspring:\n  rabbitmq:\n    username: guest\n    password: guest\n    host: localhost\n    port: 5672\n  cloud:\n    stream:\n      bindings:\n        thciwei-input:\n          destination: thciwei-topic #destination相同便能通信\n          group: g1\n          consumer: # (消费者)，开启消息分区\n            partitioned: true\n        thciwei-output:\n          destination: thciwei-topic\n          group: g1\n          producer:\n            partitioned-key-expression: 1 #生产者\n            partitioned-key-count: 2 #消费端的节点数量(生产者)\n\n      instance-count: 2 #消费者实例个数(消费者)\n      instance-index: 0 #当前实例的下标(消费者)\n```\n\nspring.cloud.stream.instance-index需要动态配置，启动两个实例\n\n```shell\njava -jar stream-0.0.1-SNAPSHOT.jar --server.port=8080 --spring.cloud.stream.instance-index=0\njava -jar stream-0.0.1-SNAPSHOT.jar --server.port=8081 --spring.cloud.stream.instance-index=1\n```\n\n访问hello接口，消息只会出现在一个实例中，因为消息分区后，相同的消息始终被同一个实例消费\n\n如果接口无效，可以使用之前的rabbitmqweb界面在队列的input发送相同的消息来测试\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4npvkjtj312k02uq5k.jpg)\n\n* 定时任务\n\nrabbitmq插件地址 [Community Plugins — RabbitMQ](https://www.rabbitmq.com/community-plugins.html)\n\n插件安装时可以直接在GitHub下载rabbitmq_delayed_message_exchange xxx.**ez**格式文件，把ez文件拷贝到docker的rabbitmq中\n\n\n\ndestination名称是固定的 delay_msg开启消息延迟的配置是cloud.stream.**rabbit**.bindings\n\n```yaml\nspring:\n  rabbitmq:\n    username: guest\n    password: guest\n    host: 8.129.122.160\n    port: 5672\n  cloud:\n    stream:\n      rabbit:\n        bindings:\n          thciwei-input:\n            consumer:\n              delayed-exchange: true #开启消息延迟\n          thciwei-output:\n            producer:\n              delayed-exchange: true\n      bindings:\n        thciwei-input:\n         destination: delay_msg\n        thciwei-output:\n           destination: delay_msg\n```\n\n正好相差三秒，通过发送消息时的setHeader(\"x-delay\",3000)\n\n```java\nHelloController\nmyChannel.output().send(MessageBuilder.withPayload(\"hello spring cloud steam\").setHeader(\"x-delay\",3000).build());\n```\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4o04zdxj318c0f2ney.jpg)\n\n\n\n## 链路追踪\n\n### sleuth\n\n访问 [localhost:8080/hello ](http://localhost:8080/hello)后打印日志\n\nINFO中依次为 应用名称、traceId、spanId、export是否对外输出，traceId和spanId为64为只显示一部分，多个span组成一个trace\n\n```logger\n2021-07-15 09:58:13.439  INFO [thciwei-sleuth,a933a66391178a1c,a933a66391178a1c,false] 17560 --- [nio-8080-exec-1] com.thciwei.sleuth.HelloController       : hello springCloud sleuth\n```\n\nspanId是不同的，因为span代表着一个调用过程，而trace是一个调用链\n\n```logger\n2021-07-15 10:04:49.875  INFO [thciwei-sleuth,530b965bc3009b33,530b965bc3009b33,false] 17608 --- [nio-8080-exec-1] com.thciwei.sleuth.HelloController       : hello2\n2021-07-15 10:04:50.424  INFO [thciwei-sleuth,530b965bc3009b33,771cf63b45a77819,false] 17608 --- [nio-8080-exec-2] com.thciwei.sleuth.HelloController       : hello3\n```\n\n异步任务spanId是不同的，但是每次的定时任务都会产生一个新的trace，spanId在每个trace中保持一致\n\n\n\n### zkpin\n\n使用es和es-head来配合链路追踪，使用docker安装\n\n该镜像不支持latest，所以要指定tag\n\n```shell\ndocker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.1.0\n```\n\n安装zipkin指定\n\n```bash\ndocker run -d -p 9411:9411 --name zipkin -e ES_HOSTS=8.129.122.160 -e STORAGE_TYPE=elasticsearch -e ES_HTTP_LOGGING=BASIC -e RABBIT_URI=amqp://guest:guest@8.129.122.160:5672  openzipkin/zipkin\n```\n\nzipkin配置\n\n```yaml\nspring:\n  application:\n    name: zipkin01\n  sleuth:\n    web:\n      client:\n        enabled: true #开启链路追踪\n    sampler:\n      probability: 1 #配置采样比例，默认为0.1\n  zipkin:\n    enabled: true #开启 zipkin\n    sender:\n      type: rabbit #追踪消息的发送类型 rabbitmq\n    base-url: http://8.129.122.160:9411\n  rabbitmq:\n    port: 5672\n    host: 8.129.122.160\n    username: guest\n    password: guest\n```\n\n\n\n## Alibaba\n\n### nacos\n\n下载server [Releases · alibaba/nacos (github.com)](https://github.com/alibaba/nacos/releases) 编译后压缩包\n\n```shell\ntar -zxvf xxx\n# 启动nacos\ncd nacos/bin\nsh startup.sh -m standalone\n```\n\n访问[http://8.129.122.160:8848](http://8.129.122.160:8848) 用户名nacos密码nacos\n\n#### 配置中心\n\n```xml\n<properties>\n    <java.version>1.8</java.version>\n    <spring-boot.version>2.2.7.RELEASE</spring-boot.version>\n    <spring-cloud-alibaba.version>2.2.0.RELEASE</spring-cloud-alibaba.version>\n</properties>\n\n <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n </dependency>\n```\n\n需要在bootstrap.properties中配置，使用yml可能有一定问题\n\n```properties\nspring.application.name=nacos\nspring.cloud.nacos.server-addr=8.129.122.160:8848\nspring.cloud.nacos.config.file-extension=properties\n```\n\n**在启动器上@EnableDiscoveryClient启动服务的注册与发现**\n\n\n\n在nacos-server中配置文件的dataId决定了application.name，此处名称是nacos，详情见PDF\n\n![image-20210718174841034.png](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4oehrcij317704n764.jpg)\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4oqqr0uj30yc0d1ac0.jpg)\n\n\n\n**HelloController**\n\n@RefreshScope是动态刷新，同springcloud-config\n\n```java\n@RestController\n@RefreshScope\npublic class HelloController {\n    @Value(\"${name}\")\n    String name1;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return name1;\n    }\n}\n```\n\n通过[localhost:8080/hello](http://localhost:8080/hello) 可以访问到nacos.properties文件中name对应的内容thciwei，如果此时修改文件内容，回到nacos主页刷新再次访问[localhost:8080/hello](http://localhost:8080/hello)，内容也随之更新\n\n* 命名空间(namespace)\n\n我们依靠不同的命名空间来做环境隔离，prop为生产环境，dev为开发环境，test为测试环境，需要注意在bootstrap.properties配置使用哪些配置，即将application.yml中的配置拆分成不同文件\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4p0ldvqj317k0g610n.jpg)\n\n```properties\nspring.application.name=gulimall-coupon\nspring.cloud.nacos.config.server-addr=8.129.122.160:8848\n# 切换到自定义的 coupon 生产环境\nspring.cloud.nacos.config.namespace=9a6f967f-612b-4fb4-9dfc-608e4bacda6d\n#配置文件没有的，默认加载prod文件配置\nspring.cloud.nacos.config.group=prod\n\n#0表示第一个配置\nspring.cloud.nacos.config.ext-config[0].data-id=datasource.yml\nspring.cloud.nacos.config.ext-config[0].group=dev\nspring.cloud.nacos.config.ext-config[0].refresh=true\n\nspring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml\nspring.cloud.nacos.config.ext-config[1].group=dev\nspring.cloud.nacos.config.ext-config[1].refresh=true\n\nspring.cloud.nacos.config.ext-config[2].data-id=other.yml\nspring.cloud.nacos.config.ext-config[2].group=dev\nspring.cloud.nacos.config.ext-config[2].refresh=true\n```\n\n\n\n\n\n#### 注册中心\n\n\n\n服务提供者\n\n```properties\n# 应用名称\nspring.application.name=nacos01\n# Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口\nspring.cloud.nacos.discovery.server-addr=8.129.122.160:8848\n```\n\n```java\n@RestController\npublic class HelloController {\n    @Value(\"${server.port}\")\n    Integer port;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"hello_\"+port;\n    }\n}\n```\n\n启动两个服务，集群\n\n```shell\njava -jar xx.jar --server.port=8080\njava -jar xx.jar --server.port=8081\n```\n\n服务消费者\n\n```properties\n# 应用名称\nspring.application.name=nacos02\n# Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口\nspring.cloud.nacos.discovery.server-addr=8.129.122.160:8848\nserver.port=8083\n```\n\n访问 [localhost:8083/hello](http://localhost:8083/hello)\n\n```java\n@RestController\npublic class HelloController {\n    @Autowired\n    RestTemplate restTemplate;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return restTemplate.getForObject(\"http://nacos01/hello\", String.class);\n    }\n\n}\n```\n\n负载均衡\n\n```java\n@SpringBootApplication\npublic class Nacos02Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Nacos02Application.class, args);\n    }\n\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n查看消费和提供者\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4pb8grcj31ew0bqtda.jpg)\n\n**整合springboot**\n\nbootstrap.properties中填入配置中心和注册中心地址\n\n```properties\nspring.cloud.nacos.discovery.server-addr=8.129.122.160:8848\nspring.cloud.nacos.config.server-addr=8.129.122.160:8848\n```\n\n在启动器处启动服务发现\n\n```java\n@EnableDiscoveryClient\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\npublic class LoafblogPictureApplication {\n```\n\n\n\n### Sentinel\n\n直接下载jar包然后本地启动 [Releases · alibaba/Sentinel (github.com)](https://github.com/alibaba/Sentinel/releases)\n\n访问http://localhost:8080/ 用户名密码为sentinel\n\n创建一个工程\n\n```\n# 应用名称\nspring.application.name=sentinel\n# 应用服务 WEB 访问端口\nserver.port=8081\n# Sentinel 控制台地址\nspring.cloud.sentinel.transport.dashboard=localhost:8080\n```\n\n访问[localhost:8081/hello](http://localhost:8081/hello) 后刷新http://localhost:8080/\n\n流量控制的使用\n\n配置每秒最多接收5个请求，后面的请求排队等待\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4q3fk44j31fj0m6wnq.jpg)\n\n发起15个请求观察流量控制结果，三秒中请求处理完成\n\n```java\nvoid contextLoads() {\n    RestTemplate restTemplate = new RestTemplate();\n    for (int i = 0; i < 15; i++) {\n        restTemplate.getForObject(\"http://localhost:8081/hello\", String.class);\n        System.out.println(new Date());\n    }\n}\n```\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4pj0l24j318b0c379g.jpg)\n\n### nacosSentinel整合\n\n在后台启动sentinel面板\n\n创建一个工程,重要的引入nacos config注册和sentinel-datasource-nacos整合两个依赖\n\n```xml\n <dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>\n </dependency>\n<dependency>\n            <groupId>com.alibaba.cloud</groupId>\n            <artifactId>spring-cloud-alibaba-nacos-config</artifactId>\n            <version>2.2.0.RELEASE</version>\n</dependency>\n<dependency>\n            <groupId>com.alibaba.csp</groupId>\n            <artifactId>sentinel-datasource-nacos</artifactId>\n            <version>1.8.2</version>\n</dependency>\n```\n\nbootstrap.properties\n\n```properties\n#需要先注册到nacos中\nspring.cloud.nacos.server-addr=8.129.122.160:8848\n```\n\napplication.properties\n\n```properties\n# 应用名称\nspring.application.name=sentinel\n# 应用服务 WEB 访问端口\nserver.port=8081\n# Sentinel 控制台地址\nspring.cloud.sentinel.transport.dashboard=localhost:8080\n#端口起作用前需要先在bootstrap配置注册到nacos中\nspring.cloud.sentinel.datasource.ds.nacos.server-addr=8.129.122.160:8848\n#配置nacos中data-id\nspring.cloud.sentinel.datasource.ds.nacos.data-id=sentinel-rule\nspring.cloud.sentinel.datasource.ds.nacos.group-id=DEFAULT_GROUP\n#配置限流规则\nspring.cloud.sentinel.datasource.ds.nacos.rule-type=flow\n```\n\nnacos中对限流的配置为一个数组，resource代表流控接口，litmitApp代表流控调用源（如app、小程序等，我们可以对它们制作不同的流控方案），grade为1代表根据QPS限流，0则是代表根据并发线程数限流，count代表阈值，clusterMode代表是否为集群，strategy代表流控模式（如直接 0），controBehavior代表流控效果（如排队等待 0）\n\n```json\n[\n    {\n        \"resource\": \"/hello\",\n        \"limitApp\": \"default\",\n        \"grade\": 1,\n        \"count\": 5,\n        \"clusterMode\": false,\n        \"strategy\": 0,\n        \"controBehavior\": 0\n    }\n]\n```\n\nHelloController访问 [localhost:8081/hello](http://localhost:8081/hello)，sentinel会自动生成对 [/hello](/hello) 接口的流控方案\n\n```java\n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"hello sentinel\";\n    }\n}\n```\n\n![](http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4prnpebj315l09t77r.jpg)\n\n', '<h2 id=\"hystrix\">Hystrix</h2>\n<p>断路器</p>\n<p>通过继承方式实现同步掉用和异步调用(入队再执行)</p>\n<pre><code class=\"java language-java\">@RestController\npublic class HelloController {\n    @Autowired\n    RestTemplate restTemplate;\n    @Autowired\n    HelloService helloService;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return helloService.hello();\n    }\n\n    @GetMapping(\"/hello2\")\n    public void hello2() {\n        HelloCommand helloCommand = new HelloCommand(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"thciwei\")), restTemplate);\n        // helloCommand.run(); 直接调用run()相当于手写一个线程再调用线程的run方法，这种方式使Hystrix的一套东西无法生效\n        /**\n         * 执行的两种方法\n         */\n        String execute = helloCommand.execute();\n        System.out.println(execute);\n        //new一个直接执行\n        HelloCommand helloCommand2 = new HelloCommand(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"thciwei\")), restTemplate);\n        try {\n            Future&lt;String&gt; queue = helloCommand2.queue();\n            String s = queue.get();\n            System.out.println(s);\n            //先入队，后执行\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n}\n</code></pre>\n<p>ctrl+o 查看HelloCommand继承的方法</p>\n<pre><code class=\"java language-java\">/**\n * 请求失败的回调\n * @return\n */\n@Override\nprotected String getFallback() {\n    return \"error-extends\";\n}\n</code></pre>\n<p>访问localhost:3000/hello2，关闭provider1114，打印出1113信息和error-extend，等待一段时间再次访问则只会出现1113信息</p>\n<h3 id=\"\">异常处理</h3>\n<p>helloservice抛出异常服务降级</p>\n<pre><code class=\"java language-java\">@HystrixCommand(fallbackMethod = \"error\")\npublic String hello() {\n    /**\n     * 异常处理 添加一个异常测试\n     */\n    int i=1/0;\n\n    return restTemplate.getForObject(\"http://provider/hello\", String.class);\n}\n</code></pre>\n<pre><code class=\"java language-java\">public String error(Throwable t) {\n    /**\n     * 大 Boos throwable 异常\n     */\n    return \"error\"+ t.getMessage();\n}\n</code></pre>\n<p>访问localhost:3000/hello，显示异常 error/ by zero</p>\n<p>HelloCommand中</p>\n<p>getExecutionException().getMessage()为自带获取异常方法</p>\n<pre><code class=\"java language-java\">@Override\nprotected String run() throws Exception {\n    int i=1/0;\n    return restTemplate.getForObject(\"http://provider/hello\",String.class);\n}\n</code></pre>\n<pre><code class=\"java language-java\">@Override\nprotected String getFallback() {\n    return \"error-extends\"+getExecutionException().getMessage();\n}\n</code></pre>\n<p>那么如何实现抛出异常服务不降级</p>\n<h3 id=\"-1\">请求合并</h3>\n<p>在provider提供一个请求的接口来解决consumer频繁调用 provider同一个接口的问题，比如通过id请求多个User数据，使用commons中的User实体</p>\n<pre><code class=\"java language-java\">@RestController\npublic class UserController {\n    @GetMapping(\"/user/{ids}\")//假设 consumer 传过来的多个id格式是 1，2，3，4....\n    public List&lt;User&gt; getUserById(@PathVariable String ids) {\n        String[] split = ids.split(\",\");\n        List&lt;User&gt; users = new ArrayList&lt;&gt;();\n        for (String s : split) {\n            User user = new User();\n            user.setId(Integer.parseInt(s));\n            users.add(user);\n        }\n        return users;\n    }\n}\n</code></pre>\n<p>创建UserService发送请求</p>\n<pre><code class=\"java language-java\">@Service\npublic class UserService {\n    @Autowired\n    RestTemplate restTemplate;\n\n    public List&lt;User&gt; getUserByIds(List&lt;Integer&gt; ids) {\n        User[] users = restTemplate.getForObject(\"http://provider/user/{1}\", User[].class, StringUtils.join(ids, \",\"));\n        return Arrays.asList(users);\n\n    }\n\n}\n</code></pre>\n<p>hystrix中创建UserBatchCommand 相当于之前的HelloCommand</p>\n<pre><code class=\"java language-java\">public class UserBatchCommand extends HystrixCommand&lt;List&lt;User&gt;&gt; {\n    private List&lt;Integer&gt; ids;\n    private UserService userService;\n\n    public UserBatchCommand(Setter setter, List&lt;Integer&gt; ids, UserService userService) {\n        super(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(\"batchCmd\")).andCommandKey(HystrixCommandKey.Factory.asKey(\"batchKey\")));\n        this.ids = ids;\n        this.userService = userService;\n    }\n\n    @Override\n    protected List&lt;User&gt; run() throws Exception {\n        return userService.getUserByIds(ids);\n    }\n}\n</code></pre>\n<p><strong>请求合并方法</strong></p>\n<pre><code class=\"java language-java\">public class UserCollapseCommand extends HystrixCollapser&lt;List&lt;User&gt;, User, Integer&gt; {\n    private UserService userService;\n    private Integer id;\n/**\n*构造器中给setter设置延迟时间，200毫秒后不再等待\n**/\n    public UserCollapseCommand(UserService userService, Integer id) {\n        super(HystrixCollapser.Setter.withCollapserKey(HystrixCollapserKey.Factory.asKey(\"UserCollapseCommand\")).andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter().withTimerDelayInMilliseconds(200)));\n        this.userService = userService;\n        this.id = id;\n    }\n\n    @Override\n    public Integer getRequestArgument() {\n        return id;\n    }\n\n    /**\n     * 请求结果合并方法\n     *\n     * @param collection\n     */\n    @Override\n    protected HystrixCommand&lt;List&lt;User&gt;&gt; createCommand(Collection&lt;CollapsedRequest&lt;User, Integer&gt;&gt; collection) {\n        ArrayList&lt;Integer&gt; ids = new ArrayList&lt;&gt;(collection.size());\n        for (CollapsedRequest&lt;User, Integer&gt; userIntegerCollapsedRequest : collection) {\n            ids.add(userIntegerCollapsedRequest.getArgument());\n        }\n        return new UserBatchCommand(ids, userService);\n    }\n\n    /**\n     * 请求结果分发\n     *\n     * @param users\n     * @param collection\n     */\n    @Override\n    protected void mapResponseToRequests(List&lt;User&gt; users, Collection&lt;CollapsedRequest&lt;User, Integer&gt;&gt; collection) {\n        int count = 0;\n        for (CollapsedRequest&lt;User, Integer&gt; request : collection) {\n            request.setResponse(users.get(count++));\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"java language-java\">@GetMapping(\"/hello5\")\npublic void hello5() throws ExecutionException, InterruptedException {\n    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();\n    UserCollapseCommand cmd1 = new UserCollapseCommand(userService, 99);\n    UserCollapseCommand cmd2 = new UserCollapseCommand(userService, 98);\n    UserCollapseCommand cmd3 = new UserCollapseCommand(userService, 97);\n    UserCollapseCommand cmd4 = new UserCollapseCommand(userService, 96);\n    Future&lt;User&gt; queue1 = cmd1.queue();\n    Future&lt;User&gt; queue2 = cmd2.queue();\n    Future&lt;User&gt; queue3 = cmd3.queue();\n    Future&lt;User&gt; queue4 = cmd4.queue();\n    User user1 = queue1.get();\n    User user2 = queue2.get();\n    User user3 = queue3.get();\n    User user3 = queue4.get();\n    System.out.println(user1);\n    System.out.println(user2);\n    System.out.println(user3);\n    System.out.println(user4);\n\n    ctx.close();\n\n}\n</code></pre>\n<p>provider收到一个请求 99 98 97 96</p>\n<p>hystrix收到分发的数据</p>\n<pre><code class=\"java language-java\">User{id=99, username=\'null\', password=\'null\'}\nUser{id=98, username=\'null\', password=\'null\'}\nUser{id=97, username=\'null\', password=\'null\'}\nUser{id=96, username=\'null\', password=\'null\'}\n</code></pre>\n<p><strong>睡眠测试</strong></p>\n<pre><code class=\"java language-java\">@GetMapping(\"/hello5\")\npublic void hello5() throws ExecutionException, InterruptedException {\n    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();\n    UserCollapseCommand cmd1 = new UserCollapseCommand(userService, 99);\n    UserCollapseCommand cmd2 = new UserCollapseCommand(userService, 98);\n    UserCollapseCommand cmd3 = new UserCollapseCommand(userService, 97);\n    Future&lt;User&gt; queue1 = cmd1.queue();\n    Future&lt;User&gt; queue2 = cmd2.queue();\n    Future&lt;User&gt; queue3 = cmd3.queue();\n    User user1 = queue1.get();\n    User user2 = queue2.get();\n    User user3 = queue3.get();\n    System.out.println(user1);\n    System.out.println(user2);\n    System.out.println(user3);\n    Thread.sleep(2000);\n    UserCollapseCommand cmd4 = new UserCollapseCommand(userService, 96);\n    Future&lt;User&gt; queue4 = cmd4.queue();\n    User user4 = queue4.get();\n    System.out.println(user4);\n    ctx.close();\n\n}\n</code></pre>\n<p>provider收到两个请求</p>\n<pre><code>97,98,99\n96\n</code></pre>\n<p>hystrix打印两个数据</p>\n<pre><code>User{id=99, username=\'null\', password=\'null\'}\nUser{id=98, username=\'null\', password=\'null\'}\nUser{id=97, username=\'null\', password=\'null\'}\n--wait\nUser{id=96, username=\'null\', password=\'null\'}\n</code></pre>\n<p><strong>注解实现合并</strong></p>\n<p>@HystrixCollapser 确定方法和参数 key-value</p>\n<p>@HystrixCommand确认方法</p>\n<pre><code class=\"java language-java\">@Service\npublic class UserService {\n    @Autowired\n    RestTemplate restTemplate;\n\n    @HystrixCollapser(batchMethod = \"getUserByIds\", collapserProperties = {@HystrixProperty(name = \"timerDelayInMilliseconds\", value = \"200\")})\n    public Future&lt;User&gt; getUserById(Integer id) {\n        return null;\n    }\n\n    @HystrixCommand\n    public List&lt;User&gt; getUserByIds(List&lt;Integer&gt; ids) {\n        User[] users = restTemplate.getForObject(\"http://provider/user/{1}\", User[].class, StringUtils.join(ids, \",\"));\n        return Arrays.asList(users);\n    }\n}\n</code></pre>\n<p>测试</p>\n<pre><code class=\"java language-java\">@GetMapping(\"/hello6\")\npublic void hello6() throws ExecutionException, InterruptedException {\n    HystrixRequestContext ctx = HystrixRequestContext.initializeContext();\n    Future&lt;User&gt; q1 = userService.getUserById(95);\n    Future&lt;User&gt; q2 = userService.getUserById(94);\n    Future&lt;User&gt; q3 = userService.getUserById(94);\n    User u1 = q1.get();\n    User u2 = q2.get();\n    User u3 = q3.get();\n    System.out.println(u1);\n    System.out.println(u2);\n    System.out.println(u3);\n    Thread.sleep(2000);\n    Future&lt;User&gt; q4 = userService.getUserById(93);\n    User u4 = q4.get();\n    System.out.println(u4);\n    ctx.close();\n\n}\n</code></pre>\n<h2 id=\"openfeign\">OpenFeign</h2>\n<p>数据传输，“省去”RestTemplate</p>\n<p>熔断降级测试时，需关闭provider后访问 [localhost:4000/hello]() 方可出现error，服务降级的配置生效</p>\n<h2 id=\"resilience4j\">resilience4j</h2>\n<p>断路器</p>\n<h3 id=\"-2\">策略配置</h3>\n<p>— 表示数组</p>\n<pre><code class=\"yaml language-yaml\">resilience4j:\n  retry:\n    retry-aspect-order: 399  # retry优先级 默认高于限流和断路器,数字越小优先级越高\n    backends: #配置不同的策略\n      retryA:\n        maxRetryAttempt: 5 # 重试次数\n        waitDuration: 500 # 重试等待时间\n        exponentialBackoffMultiplier: 1.1 #间隔乘数\n        retryExceptions: # 异常配置为一个数组\n          - java.lang.RuntimeException\n  circuitbreaker:\n    instances:\n      cbA:\n        ringBufferSizeInClosedState: 5\n        ringBufferSizeInOpenState: 3\n        waitInterval: 5000  # 断路器从open切换到 half open的时间间隔\n        recordException:\n          - org.springframework.web.client.HttpServerErrorException\n    circuit-breaker-aspect-order: 398\nspring:\n  application:\n    name: resilience4j\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nserver:\n  port: 5000\n</code></pre>\n<h3 id=\"-3\">熔断降级</h3>\n<pre><code class=\"java language-java\">@Service\n@CircuitBreaker(name = \"cbA\", fallbackMethod = \"error\") //断路器\npublic class HelloService {\n    @Autowired\n    RestTemplate restTemplate;\n    public String hello() {\n        return restTemplate.getForObject(\"http://localhost:1113/hello\", String.class);\n    }\n\n    public String error() {\n        return \"error\";\n    }\n}\n</code></pre>\n<p>报错分析</p>\n<pre><code>java.lang.NoSuchMethodException: class java.lang.String class com.thciwei.resilience4j2.HelloService.error(,class java.lang.Throwable)\n</code></pre>\n<p>结合最后括号中的话可知，error方法缺少异常信息Boos -&gt;Throwable参数</p>\n<pre><code class=\"java language-java\">public String error(Throwable t) {\n    return \"error\" + t.getMessage();\n}\n</code></pre>\n<h3 id=\"-4\">模拟限流</h3>\n<p>因为限流是生效在客户端的，所以provider也要配置，反复刷新web页面，因为每秒只能处理一个请求，请求过多时发生熔断降级</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  application:\n    name: provider\nserver:\n  port: 1113\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nresilience4j:\n  ratelimiter:\n   limiters:\n    rlA:  # 每秒钟处理一个请求、刷新周期、冷却时间(刷新后的冷却时间)\n     limit-for-period: 1\n     limit-refresh-period: 1s\n     timeout-duration: 1s\n</code></pre>\n<pre><code class=\"java language-java\">@Service\n@CircuitBreaker(name = \"cbA\", fallbackMethod = \"error\") //断路器\npublic class HelloService {\n    @Autowired\n    RestTemplate restTemplate;\n\n    public String hello() {\n        //使用循环模拟多请求\n        for (int i = 0; i &lt; 5; i++) {\n            restTemplate.getForObject(\"http://localhost:1113/hello\", String.class);\n        }\n        return \"success\";\n    }\n\n    public String error(Throwable t) {\n        return \"error\" + t.getMessage();\n    }\n}\n</code></pre>\n<h2 id=\"-5\">服务监控</h2>\n<p>Prometheus</p>\n<p>Grafana </p>\n<p>推荐文章：https://urlify.cn/fua2aa</p>\n<pre><code class=\"shell language-shell\">安装命令：\nrpm -ivh grafana-6.7.4-1.x86_64.rpm \n查看安装：\nrpm -q grafana\n卸载：\nrpm -e grafana\n启动和停止命令：\nsystemctl start grafana-server\nsystemctl stop grafana-server\n</code></pre>\n<h2 id=\"gateway\">Gateway</h2>\n<p>网关，以多种过滤器实现</p>\n<p>测试接口： <a href=\"http://httpbin.org/get\">httpbin.org/get</a></p>\n<p>配置文件</p>\n<p>Gateway实现对provider的代理</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  cloud:\n    gateway:\n      routes:\n        - id: thciwei_route\n          uri: http://httpbin.org\n          predicates:\n            - Path=/get\n      discovery:\n        locator:\n          enabled: true #开启自动代理\n  application:\n    name: gateway\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nlogging:\n  level:\n    org.springframework.cloud.gateway: debug\n</code></pre>\n<p>访问 <a href=\"http://localhost:8080/PROVIDER/hello\">localhost:8080/PROVIDER/hello</a></p>\n<p>查看eureka注册中心得知，provider需要大写</p>\n<h3 id=\"predicates\">predicates</h3>\n<p>predicates路径匹配有多种方式</p>\n<p>使用postman测试各种匹配</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  cloud:\n    gateway:\n      routes:\n        - id: thciwei_route\n          uri: http://httpbin.org\n          predicates:\n            - After=2021-01-01T01:01:01+08:00[Asia/Shanghai] #转发\n            - After=2022-01-01T01:01:01+08:00[Asia/Shanghai] #404不转发\n            - Before=\n            - Between= \n            - Method=GET #只转发get请求\n            - Path=/2019/0612/{segments} \n            - Query=name\n            - Query=name,java.* #key为name，value中需要含有java字样，否则不转发\n</code></pre>\n<ul>\n<li><p>Path=/2019/0612/{segments} 如 http://localhost:8080/2019/0612/git-install.html</p></li>\n<li><p>Query=name如 http://localhost:8080/get?name=javaboy</p></li>\n<li><p>Query=name,java.*如 http://localhost:8080/get?name=javboy</p></li>\n</ul>\n<p><strong>匹配方式可以组合使用，如果多个匹配方式，优先选择第一个被匹配上的方式作为标准</strong></p>\n<h3 id=\"filter\">filter</h3>\n<p>hello2是provider中IUserService的一个带参数的接口，且要求必须带有参数name</p>\n<pre><code class=\"java language-java\">--  IUserService\n@GetMapping(\"/hello2\")\n    String hello2(@RequestParam(\"name\") String name);\n-- HelloController\n@Override\npublic String hello2(String name) {\n    System.out.println(new Date() + \"&gt;&gt;&gt;\" + name);\n    return \"hello2:\" + name;\n}\n</code></pre>\n<p>lb是loadBanlanced…，转发到provider时自动负载均衡，AddRequestParameter可以在转发时自动帮你来添加参数 name=thciwei</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  cloud:\n    gateway:\n      routes:\n        - id: thciwei_route\n          uri: lb://provider\n          filters:\n            - AddRequestParameter=name,thciwei\n          predicates:\n            - Method=Get\n      discovery:\n        locator:\n          enabled: true #开启自动代理\n  application:\n    name: gateway\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\nlogging:\n  level:\n    org.springframework.cloud.gateway: debug\n</code></pre>\n<p>这里访问 <a href=\"http://localhost:8080/hello2\">localhost:8080/hello2</a> 即可，直接访问 <a href=\"http://localhost:1113/hello2\">localhost:1113/hello2 </a>不可以，访问 <a href=\"http://localhost:8080/PROVIDER/hello2\">localhost:8080/PROVIDER/hello2</a> 也没有作用，一切以routes中uri 的配置为准</p>\n<p>或者url请求中含有某些字段，则指定跳转页面，<a href=\"http://localhost:88?url=qq\">localhost:88?url=qq</a></p>\n<pre><code class=\"yaml language-yaml\">spring:\n  cloud:\n    gateway:\n      routes:\n        - id: baidu_route\n          uri: https://wwww.baidu.com\n          predicates:\n            - Query=url,baidu\n        - id: qq_route\n          uri: https://www.qq.com\n          predicates:\n            - Query=url,qq\n</code></pre>\n<h2 id=\"config\">Config</h2>\n<p>分布式配置管理中心</p>\n<h3 id=\"git\">git上传</h3>\n<p>GitHub创建configRepo仓库，通过提示的指令上传文件</p>\n<p>本地准备好相应的配置文件，提交到github https://github.com/thciwei/configRepo/tree/master/client</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4lwbflkj31du046dhr.jpg\" alt=\"\" /></p>\n<p>内容分别为 thciwei=dev,thciwei=prod,thciwei=test</p>\n<p>运行config后访问 <a href=\"http://localhost:8081/client1/dev/master\">localhost:8081/client1/dev/master</a></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4m5occhj316k01xgnu.jpg\" alt=\"\" /></p>\n<p>D:/temp1/config-repo-6314996172738589608/client1是config帮我们克隆到本地的一份文件，下次读取直接在本地读取</p>\n<p>web页面可以通过 <a href=\"http://localhost:8081/client1-prod.yml\">localhost:8081/client1-prod.yml</a>、<a href=\"http://localhost:8081/client1-prod.properties\">localhost:8081/client1-prod.properties</a> 的方式访问到文件内容</p>\n<p>修改文件内容，重新提交到GitHub</p>\n<pre><code class=\"git language-git\">git add .\ngit commit -m \"first add\"\ngit push\npush失败时可以采用 git push -f\n</code></pre>\n<p>刷新web页面即可显示最新的内容</p>\n<p>在 client中新建bootstrap.yml抢先在application.yml前加载</p>\n<pre><code class=\"yaml language-yaml\">#config下三行配置对应着config-server的 {application} {profile} {label} 的占位符\nspring:\n  application:\n    name: client1\n  cloud:\n    config:\n      profile: dev\n      label: master\n      uri: http://localhost:8081\nserver:\n  port: 8082\n</code></pre>\n<p>创建HelloController读取文件</p>\n<pre><code class=\"java language-java\">package com.thciwei.configclient;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n    @Value(\"${thciwei}\")\n    String thciwei;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return thciwei;\n    }\n}\n</code></pre>\n<p>访问 <a href=\"http://localhost:8082/hello\">localhost:8082/hello</a> ,显示内容 dev</p>\n<h3 id=\"-6\">密码加密</h3>\n<p>下载不限制长度的 jce https://www.oracle.com/java/technologies/javase-jce8-downloads.html，解压拷贝jar包到C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\security</p>\n<p>存储时添加{cipher}前缀，否则会认定为普通字符串</p>\n<pre><code class=\"properties language-properties\">thciwei={cipher}73769b7b0b414540bd97c1135ea13a3668b577347e51f30ba77c157cde85e0c3\n</code></pre>\n<p>config-server中bootstrap.yml需要配置密钥</p>\n<pre><code class=\"yaml language-yaml\">#密钥\nencrypt:\n  key: thciwei\n</code></pre>\n<p>将文件添加密文标识后，访问接口仍然不能解密，这里涉及配置是否能及时感知的问题，后面可以用消息队列等方法解决，暂时只能重启client服务后再次访问接口</p>\n<p>config-server读取这些资源</p>\n<pre><code class=\"xml language-xml\">&lt;build&gt;\n    &lt;resources&gt;\n        &lt;resource&gt;\n            &lt;directory&gt;src/main/resources&lt;/directory&gt;\n            &lt;includes&gt;\n                &lt;include&gt;**/*.yml&lt;/include&gt;\n                &lt;include&gt;**/*.keystore&lt;/include&gt;\n            &lt;/includes&gt;\n        &lt;/resource&gt;\n    &lt;/resources&gt;\n&lt;/build&gt;\n</code></pre>\n<h3 id=\"-7\">安全管理</h3>\n<pre><code class=\"xml language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n    &lt;version&gt;2.5.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>添加完依赖接口就会自动被spring-security保护起来了，使用user和密码（控制台获取）登录后访问<a href=\"http://localhost:8081/client1/dev\">localhost:8081/client1/dev</a> ，此时启动config-client便会报错，因为失去了凭证</p>\n<h3 id=\"-8\">服务化</h3>\n<p>config-client和config-server需要添加spring-security的依赖，因为之前的<strong>keystore会造成冲突</strong>，这里换成 jks，并更换掉alias、username和password</p>\n<pre><code class=\"shell language-shell\"> keytool -genkeypair -alias mytestkey -keyalg RSA -keypass 111111 -keystore D:\\javabootList\\config-service.jks -storepass 111111\n</code></pre>\n<p>config-server资源读取</p>\n<pre><code class=\"xml language-xml\">&lt;include&gt;**/*.jks&lt;/include&gt;\n</code></pre>\n<p>congfig-server/bootstrap.yml</p>\n<pre><code class=\"yaml language-yaml\">#密钥\n#encrypt:\n#  key: thciwei\nencrypt:\n  key-store:\n    location:\n     classpath: config-service.jks\n    password: 111111\n    secret: 1111111\n    alias: mytestkey\nspring:\n  security:\n    user:\n     name: thciwei\n     password: thciwei\n</code></pre>\n<p>配置eureka注册时，config-server的配置可以放在application.yml，但是config-client的配置需要放在bootstrap.yml中</p>\n<p>config-server/application.yml</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  application:\n    name: config-server\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/thciwei/configRepo.git\n          search-paths: {application}  #动态，如果报错可换回client1\n          username:\n          password:\nserver:\n  port: 8081\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\n</code></pre>\n<p>client/bootstrap.yml</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  application:\n    name: client1\n  cloud:\n    config:\n      profile: test\n      label: master\n      #uri: http://localhost:8081\n      username: thciwei\n      password: thciwei\n      #开启服务 eureka获取 config-server 的功能\n      discovery:\n        enabled: true\n        service-id: config-server #配置 config-server 名称\nserver:\n  port: 8082\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:1111/eureka\n</code></pre>\n<h3 id=\"-9\">动态刷新</h3>\n<p>生产中动态刷新还是要配合消息中间件的，这里添加actuator依赖通过调用的接口方式手动进行刷新</p>\n<pre><code class=\"xml language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>对应需访问的接口类如HelloController<strong>添加</strong>@RefreshScope注解</p>\n<p>config-client\\bootstrap.yml添加对端点的自动刷新配置</p>\n<pre><code class=\"yaml language-yaml\">management:\n  endpoints:\n    web:\n      exposure:\n        include: refresh\n</code></pre>\n<p>更改configRepo中test文件的内容，然后用git提交到GitHub，使用postman对接口 <a href=\"http://localhost:8082/actuator/refresh\">localhost:8082/actuator/refresh</a>  发送post请求刷新，再次访问 <a href=\"http://localhost:8082/hello\">localhost:8082/hello</a> 获得更新后的数据</p>\n<p>重试retry</p>\n<p>通过添加aop和spring-retry的依赖</p>\n<pre><code class=\"xml language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;\n    &lt;version&gt;1.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n    &lt;version&gt;2.2.7.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>在bootstr.yml配置retry</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  application:\n    name: client1\n  cloud:\n    config:\n      profile: test\n      label: master\n      #uri: http://localhost:8081\n      username: thciwei\n      password: thciwei\n      #开启服务 eureka获取 config-server 的功能\n      discovery:\n        enabled: true\n        service-id: config-server #配置 config-server 名称\n      fail-fast: true # 开启快速响应\n      retry:\n        initial-interval: 1000 #请求重试初始时间间隔 \n        max-attempts: 6 #最大重试次数\n        multiplier: 1.1 #重试时间乘数\n        max-interval: 2000 #最大时间间隔\n</code></pre>\n<p>开启快速响应的目的，在config-server加载不到数据时就解决问题，否则就要等到HellController时再抛出错误，这样是不合理的</p>\n<p>通过注释掉username和password重启client可以测试错误的抛出和重试</p>\n<h2 id=\"bus\">Bus</h2>\n<p>消息总线</p>\n<p>config-server\\bootstrap.yml</p>\n<pre><code class=\"yaml language-yaml\">management:\n  endpoints:\n    web:\n      exposure:\n        include: bus-refresh\n</code></pre>\n<p>修改configRepo中test文件，使用postman对config-server的bus-refresh接口发送post请求，server在bus上把指令传给rabbitmq，会通过rabbitmq把刷新指令传递到config的每一个client，实现自动更新文件，最后访问 <a href=\"http://localhost:8082/hello\">localhost:8082/hello</a></p>\n<p>因为springsecurity中配置的.httpBasic()，type选择<strong>basic auth</strong>，用户名密码使用yml配置，请求无响应表示成功</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4mnn386j31cx0a1q5p.jpg\" alt=\"\" /></p>\n<p>server中需要bus和actuator的依赖，client需要bus的依赖</p>\n<pre><code class=\"xml language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre>\n<ul>\n<li>多个刷新</li>\n</ul>\n<p>java -jar启动8082和8083两个服务，只刷新某一个client服务则添加service-id http://localhost:8081/actuator/bus-refresh/client1:8082</p>\n<h2 id=\"stream\">Stream</h2>\n<p>表示stream连接上了rabbitmq</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4myq4qlj315i01u76u.jpg\" alt=\"\" /></p>\n<p>使用rabbitmq发送消息</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4n6qo70j30xg0kawim.jpg\" alt=\"\" /></p>\n<p>控制台可检查收到的消息</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4ni9sdoj316400tmyd.jpg\" alt=\"\" /></p>\n<pre><code class=\"yaml language-yaml\">spring:\n  rabbitmq:\n    username: guest\n    password: guest\n    host: localhost\n    port: 5672\n  cloud:\n    stream:\n      bindings:\n        thciwei-input: \n          destination: thciwei-topic #destination相同便能保证收发消息\n          group: g1 # 消息分组\n        thciwei-output:\n          destination: thciwei-topic\n          group: g1 # 消息分组\n</code></pre>\n<ul>\n<li>消息分组</li>\n</ul>\n<p>分组后消息只能被一个实例所消费，创建一个消费者集群</p>\n<pre><code class=\"shell language-shell\">java -jar stream-0.0.1-SNAPSHOT.jar --server.port=8080\njava -jar stream-0.0.1-SNAPSHOT.jar --server.port=8081\n</code></pre>\n<p>在控制台右击clear buffer后，访问hello接口 <a href=\"http://localhost:8080/hello\">localhost:8080/hello</a>，消息只会被其中一个实例接收，访问两次接口结果更直观</p>\n<ul>\n<li>消息分区</li>\n</ul>\n<pre><code class=\"yaml language-yaml\">spring:\n  rabbitmq:\n    username: guest\n    password: guest\n    host: localhost\n    port: 5672\n  cloud:\n    stream:\n      bindings:\n        thciwei-input:\n          destination: thciwei-topic #destination相同便能通信\n          group: g1\n          consumer: # (消费者)，开启消息分区\n            partitioned: true\n        thciwei-output:\n          destination: thciwei-topic\n          group: g1\n          producer:\n            partitioned-key-expression: 1 #生产者\n            partitioned-key-count: 2 #消费端的节点数量(生产者)\n\n      instance-count: 2 #消费者实例个数(消费者)\n      instance-index: 0 #当前实例的下标(消费者)\n</code></pre>\n<p>spring.cloud.stream.instance-index需要动态配置，启动两个实例</p>\n<pre><code class=\"shell language-shell\">java -jar stream-0.0.1-SNAPSHOT.jar --server.port=8080 --spring.cloud.stream.instance-index=0\njava -jar stream-0.0.1-SNAPSHOT.jar --server.port=8081 --spring.cloud.stream.instance-index=1\n</code></pre>\n<p>访问hello接口，消息只会出现在一个实例中，因为消息分区后，相同的消息始终被同一个实例消费</p>\n<p>如果接口无效，可以使用之前的rabbitmqweb界面在队列的input发送相同的消息来测试</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4npvkjtj312k02uq5k.jpg\" alt=\"\" /></p>\n<ul>\n<li>定时任务</li>\n</ul>\n<p>rabbitmq插件地址 <a href=\"https://www.rabbitmq.com/community-plugins.html\">Community Plugins — RabbitMQ</a></p>\n<p>插件安装时可以直接在GitHub下载rabbitmq<em>delayed</em>message_exchange xxx.<strong>ez</strong>格式文件，把ez文件拷贝到docker的rabbitmq中</p>\n<p>destination名称是固定的 delay_msg开启消息延迟的配置是cloud.stream.<strong>rabbit</strong>.bindings</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  rabbitmq:\n    username: guest\n    password: guest\n    host: 8.129.122.160\n    port: 5672\n  cloud:\n    stream:\n      rabbit:\n        bindings:\n          thciwei-input:\n            consumer:\n              delayed-exchange: true #开启消息延迟\n          thciwei-output:\n            producer:\n              delayed-exchange: true\n      bindings:\n        thciwei-input:\n         destination: delay_msg\n        thciwei-output:\n           destination: delay_msg\n</code></pre>\n<p>正好相差三秒，通过发送消息时的setHeader(\"x-delay\",3000)</p>\n<pre><code class=\"java language-java\">HelloController\nmyChannel.output().send(MessageBuilder.withPayload(\"hello spring cloud steam\").setHeader(\"x-delay\",3000).build());\n</code></pre>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4o04zdxj318c0f2ney.jpg\" alt=\"\" /></p>\n<h2 id=\"-10\">链路追踪</h2>\n<h3 id=\"sleuth\">sleuth</h3>\n<p>访问 <a href=\"http://localhost:8080/hello\">localhost:8080/hello </a>后打印日志</p>\n<p>INFO中依次为 应用名称、traceId、spanId、export是否对外输出，traceId和spanId为64为只显示一部分，多个span组成一个trace</p>\n<pre><code class=\"logger language-logger\">2021-07-15 09:58:13.439  INFO [thciwei-sleuth,a933a66391178a1c,a933a66391178a1c,false] 17560 --- [nio-8080-exec-1] com.thciwei.sleuth.HelloController       : hello springCloud sleuth\n</code></pre>\n<p>spanId是不同的，因为span代表着一个调用过程，而trace是一个调用链</p>\n<pre><code class=\"logger language-logger\">2021-07-15 10:04:49.875  INFO [thciwei-sleuth,530b965bc3009b33,530b965bc3009b33,false] 17608 --- [nio-8080-exec-1] com.thciwei.sleuth.HelloController       : hello2\n2021-07-15 10:04:50.424  INFO [thciwei-sleuth,530b965bc3009b33,771cf63b45a77819,false] 17608 --- [nio-8080-exec-2] com.thciwei.sleuth.HelloController       : hello3\n</code></pre>\n<p>异步任务spanId是不同的，但是每次的定时任务都会产生一个新的trace，spanId在每个trace中保持一致</p>\n<h3 id=\"zkpin\">zkpin</h3>\n<p>使用es和es-head来配合链路追踪，使用docker安装</p>\n<p>该镜像不支持latest，所以要指定tag</p>\n<pre><code class=\"shell language-shell\">docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.1.0\n</code></pre>\n<p>安装zipkin指定</p>\n<pre><code class=\"bash language-bash\">docker run -d -p 9411:9411 --name zipkin -e ES_HOSTS=8.129.122.160 -e STORAGE_TYPE=elasticsearch -e ES_HTTP_LOGGING=BASIC -e RABBIT_URI=amqp://guest:guest@8.129.122.160:5672  openzipkin/zipkin\n</code></pre>\n<p>zipkin配置</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  application:\n    name: zipkin01\n  sleuth:\n    web:\n      client:\n        enabled: true #开启链路追踪\n    sampler:\n      probability: 1 #配置采样比例，默认为0.1\n  zipkin:\n    enabled: true #开启 zipkin\n    sender:\n      type: rabbit #追踪消息的发送类型 rabbitmq\n    base-url: http://8.129.122.160:9411\n  rabbitmq:\n    port: 5672\n    host: 8.129.122.160\n    username: guest\n    password: guest\n</code></pre>\n<h2 id=\"alibaba\">Alibaba</h2>\n<h3 id=\"nacos\">nacos</h3>\n<p>下载server <a href=\"https://github.com/alibaba/nacos/releases\">Releases · alibaba/nacos (github.com)</a> 编译后压缩包</p>\n<pre><code class=\"shell language-shell\">tar -zxvf xxx\n# 启动nacos\ncd nacos/bin\nsh startup.sh -m standalone\n</code></pre>\n<p>访问<a href=\"http://8.129.122.160:8848\">http://8.129.122.160:8848</a> 用户名nacos密码nacos</p>\n<h4 id=\"-11\">配置中心</h4>\n<pre><code class=\"xml language-xml\">&lt;properties&gt;\n    &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;spring-boot.version&gt;2.2.7.RELEASE&lt;/spring-boot.version&gt;\n    &lt;spring-cloud-alibaba.version&gt;2.2.0.RELEASE&lt;/spring-cloud-alibaba.version&gt;\n&lt;/properties&gt;\n\n &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;\n &lt;/dependency&gt;\n</code></pre>\n<p>需要在bootstrap.properties中配置，使用yml可能有一定问题</p>\n<pre><code class=\"properties language-properties\">spring.application.name=nacos\nspring.cloud.nacos.server-addr=8.129.122.160:8848\nspring.cloud.nacos.config.file-extension=properties\n</code></pre>\n<p><strong>在启动器上@EnableDiscoveryClient启动服务的注册与发现</strong></p>\n<p>在nacos-server中配置文件的dataId决定了application.name，此处名称是nacos，详情见PDF</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4oehrcij317704n764.jpg\" alt=\"image-20210718174841034.png\" /></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4oqqr0uj30yc0d1ac0.jpg\" alt=\"\" /></p>\n<p><strong>HelloController</strong></p>\n<p>@RefreshScope是动态刷新，同springcloud-config</p>\n<pre><code class=\"java language-java\">@RestController\n@RefreshScope\npublic class HelloController {\n    @Value(\"${name}\")\n    String name1;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return name1;\n    }\n}\n</code></pre>\n<p>通过<a href=\"http://localhost:8080/hello\">localhost:8080/hello</a> 可以访问到nacos.properties文件中name对应的内容thciwei，如果此时修改文件内容，回到nacos主页刷新再次访问<a href=\"http://localhost:8080/hello\">localhost:8080/hello</a>，内容也随之更新</p>\n<ul>\n<li>命名空间(namespace)</li>\n</ul>\n<p>我们依靠不同的命名空间来做环境隔离，prop为生产环境，dev为开发环境，test为测试环境，需要注意在bootstrap.properties配置使用哪些配置，即将application.yml中的配置拆分成不同文件</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4p0ldvqj317k0g610n.jpg\" alt=\"\" /></p>\n<pre><code class=\"properties language-properties\">spring.application.name=gulimall-coupon\nspring.cloud.nacos.config.server-addr=8.129.122.160:8848\n# 切换到自定义的 coupon 生产环境\nspring.cloud.nacos.config.namespace=9a6f967f-612b-4fb4-9dfc-608e4bacda6d\n#配置文件没有的，默认加载prod文件配置\nspring.cloud.nacos.config.group=prod\n\n#0表示第一个配置\nspring.cloud.nacos.config.ext-config[0].data-id=datasource.yml\nspring.cloud.nacos.config.ext-config[0].group=dev\nspring.cloud.nacos.config.ext-config[0].refresh=true\n\nspring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml\nspring.cloud.nacos.config.ext-config[1].group=dev\nspring.cloud.nacos.config.ext-config[1].refresh=true\n\nspring.cloud.nacos.config.ext-config[2].data-id=other.yml\nspring.cloud.nacos.config.ext-config[2].group=dev\nspring.cloud.nacos.config.ext-config[2].refresh=true\n</code></pre>\n<h4 id=\"-12\">注册中心</h4>\n<p>服务提供者</p>\n<pre><code class=\"properties language-properties\"># 应用名称\nspring.application.name=nacos01\n# Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口\nspring.cloud.nacos.discovery.server-addr=8.129.122.160:8848\n</code></pre>\n<pre><code class=\"java language-java\">@RestController\npublic class HelloController {\n    @Value(\"${server.port}\")\n    Integer port;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"hello_\"+port;\n    }\n}\n</code></pre>\n<p>启动两个服务，集群</p>\n<pre><code class=\"shell language-shell\">java -jar xx.jar --server.port=8080\njava -jar xx.jar --server.port=8081\n</code></pre>\n<p>服务消费者</p>\n<pre><code class=\"properties language-properties\"># 应用名称\nspring.application.name=nacos02\n# Nacos 服务发现与注册配置，其中子属性 server-addr 指定 Nacos 服务器主机和端口\nspring.cloud.nacos.discovery.server-addr=8.129.122.160:8848\nserver.port=8083\n</code></pre>\n<p>访问 <a href=\"http://localhost:8083/hello\">localhost:8083/hello</a></p>\n<pre><code class=\"java language-java\">@RestController\npublic class HelloController {\n    @Autowired\n    RestTemplate restTemplate;\n\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return restTemplate.getForObject(\"http://nacos01/hello\", String.class);\n    }\n\n}\n</code></pre>\n<p>负载均衡</p>\n<pre><code class=\"java language-java\">@SpringBootApplication\npublic class Nacos02Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Nacos02Application.class, args);\n    }\n\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n</code></pre>\n<p>查看消费和提供者</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4pb8grcj31ew0bqtda.jpg\" alt=\"\" /></p>\n<p><strong>整合springboot</strong></p>\n<p>bootstrap.properties中填入配置中心和注册中心地址</p>\n<pre><code class=\"properties language-properties\">spring.cloud.nacos.discovery.server-addr=8.129.122.160:8848\nspring.cloud.nacos.config.server-addr=8.129.122.160:8848\n</code></pre>\n<p>在启动器处启动服务发现</p>\n<pre><code class=\"java language-java\">@EnableDiscoveryClient\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\npublic class LoafblogPictureApplication {\n</code></pre>\n<h3 id=\"sentinel\">Sentinel</h3>\n<p>直接下载jar包然后本地启动 <a href=\"https://github.com/alibaba/Sentinel/releases\">Releases · alibaba/Sentinel (github.com)</a></p>\n<p>访问http://localhost:8080/ 用户名密码为sentinel</p>\n<p>创建一个工程</p>\n<pre><code># 应用名称\nspring.application.name=sentinel\n# 应用服务 WEB 访问端口\nserver.port=8081\n# Sentinel 控制台地址\nspring.cloud.sentinel.transport.dashboard=localhost:8080\n</code></pre>\n<p>访问<a href=\"http://localhost:8081/hello\">localhost:8081/hello</a> 后刷新http://localhost:8080/</p>\n<p>流量控制的使用</p>\n<p>配置每秒最多接收5个请求，后面的请求排队等待</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4q3fk44j31fj0m6wnq.jpg\" alt=\"\" /></p>\n<p>发起15个请求观察流量控制结果，三秒中请求处理完成</p>\n<pre><code class=\"java language-java\">void contextLoads() {\n    RestTemplate restTemplate = new RestTemplate();\n    for (int i = 0; i &lt; 15; i++) {\n        restTemplate.getForObject(\"http://localhost:8081/hello\", String.class);\n        System.out.println(new Date());\n    }\n}\n</code></pre>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4pj0l24j318b0c379g.jpg\" alt=\"\" /></p>\n<h3 id=\"nacossentinel\">nacosSentinel整合</h3>\n<p>在后台启动sentinel面板</p>\n<p>创建一个工程,重要的引入nacos config注册和sentinel-datasource-nacos整合两个依赖</p>\n<pre><code class=\"xml language-xml\"> &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;\n &lt;/dependency&gt;\n&lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-nacos-config&lt;/artifactId&gt;\n            &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;\n            &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;\n            &lt;version&gt;1.8.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>bootstrap.properties</p>\n<pre><code class=\"properties language-properties\">#需要先注册到nacos中\nspring.cloud.nacos.server-addr=8.129.122.160:8848\n</code></pre>\n<p>application.properties</p>\n<pre><code class=\"properties language-properties\"># 应用名称\nspring.application.name=sentinel\n# 应用服务 WEB 访问端口\nserver.port=8081\n# Sentinel 控制台地址\nspring.cloud.sentinel.transport.dashboard=localhost:8080\n#端口起作用前需要先在bootstrap配置注册到nacos中\nspring.cloud.sentinel.datasource.ds.nacos.server-addr=8.129.122.160:8848\n#配置nacos中data-id\nspring.cloud.sentinel.datasource.ds.nacos.data-id=sentinel-rule\nspring.cloud.sentinel.datasource.ds.nacos.group-id=DEFAULT_GROUP\n#配置限流规则\nspring.cloud.sentinel.datasource.ds.nacos.rule-type=flow\n</code></pre>\n<p>nacos中对限流的配置为一个数组，resource代表流控接口，litmitApp代表流控调用源（如app、小程序等，我们可以对它们制作不同的流控方案），grade为1代表根据QPS限流，0则是代表根据并发线程数限流，count代表阈值，clusterMode代表是否为集群，strategy代表流控模式（如直接 0），controBehavior代表流控效果（如排队等待 0）</p>\n<pre><code class=\"json language-json\">[\n    {\n        \"resource\": \"/hello\",\n        \"limitApp\": \"default\",\n        \"grade\": 1,\n        \"count\": 5,\n        \"clusterMode\": false,\n        \"strategy\": 0,\n        \"controBehavior\": 0\n    }\n]\n</code></pre>\n<p>HelloController访问 <a href=\"http://localhost:8081/hello\">localhost:8081/hello</a>，sentinel会自动生成对 <a href=\"/hello\">/hello</a> 接口的流控方案</p>\n<pre><code class=\"java language-java\">@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"hello sentinel\";\n    }\n}\n</code></pre>\n<p><img src=\"http://tva1.sinaimg.cn/large/006yRl4Gly1h2e4prnpebj315l09t77r.jpg\" alt=\"\" /></p>', '个人学习笔记，仅供参考，Spring Cloud学习笔记', 'http://gulimall-wqs.oss-cn-beijing.aliyuncs.com/2023-05-03/a55e3b16-da91-4327-842c-bb9ba08a2ec8_logo.png', '2023-05-03 17:10:32', 1, 1, 5072, 0);
INSERT INTO `article` VALUES (32, '整合阿里云oss', 3, 2, '[面包博客](https://gitee.com/thciweicloud/loafblog)一直想要高效的管理图片资源，为了节约服务器资源，可以选择阿里云OSS存储，并且它和SpringCloud Alibaba又是天然融合\n\n\n服务流程：用户将图片等资源传到服务器，服务器接收处理后再传给我们的阿里云OSS存储，但这样势必会带来大量的流量带宽消耗；所以有了第二种方式，通过policy策略，也就是提前获取签名的方式，将文件资源和签名共同提交给OSS进行验证继而存储，省去了通过服务器的消耗步骤，完成了资源的节约\n\n下面是代码，以springcloud为例：\n\n如果你使用了springcloud-gateway，网关会对资源传输的大小进行限制，导致报错，所以要进行相应的配置\n\n```yaml\nspring:\n  application:\n    name: loafblog-picture\n  cloud:\n    alicloud:\n      access-key: LTAI5tBKticuE4GnKjdzUmx6\n      secret-key: EAVjuJaAXB9yZLSPV2k4rsbtdq6860\n      oss:\n        endpoint: oss-cn-beijing.aliyuncs.com\n        bucket: gulimall-wqs\n  servlet:    #配置文件阈值    \n   multipart: \n     max-file-size: 10MB\n     max-request-size: 100MB\n```\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alicloud-oss</artifactId>\n    <version>2.2.0.RELEASE</version>\n</dependency>\n```\n\n```java\n@RestController\n@RequestMapping(\"picture\")\npublic class OssController {\n    /**\n     * ossClient这里要使用父类\n     */\n    @Autowired\n    OSS ossClient;\n    @Autowired\n    OssService ossService;\n\n    @Value(\"${spring.cloud.alicloud.oss.endpoint}\")\n    private String endpoint;\n    @Value(\"${spring.cloud.alicloud.oss.bucket}\")\n    private String bucket;\n    @Value(\"${spring.cloud.alicloud.access-key}\")\n    private String accessId;\n\n    @GetMapping(\"/id\")\n    public R test1() {\n        return R.ok().put(\"data\", 1);\n    }\n\n    /**\n     * 签名直接上传到oss\n     *\n     * @return\n     */\n    @RequestMapping(\"/oss/policy\")\n    public R policy() {\n        String host = \"https://\" + bucket + \".\" + endpoint; // host的格式为 bucketname.endpoint\n        // callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。\n        //   String callbackUrl = \"http://88.88.88.88:8888\";\n        String format = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n        String dir = format + \"/\"; // 用户上传文件时指定的前缀。\n\n        Map<String, String> respMap = null;\n\n        try {\n            long expireTime = 30;\n            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;\n            Date expiration = new Date(expireEndTime);\n            // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。\n            PolicyConditions policyConds = new PolicyConditions();\n            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);\n            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);\n\n            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);\n            byte[] binaryData = postPolicy.getBytes(\"utf-8\");\n            String encodedPolicy = BinaryUtil.toBase64String(binaryData);\n            String postSignature = ossClient.calculatePostSignature(postPolicy);\n\n            respMap = new LinkedHashMap<String, String>();\n            respMap.put(\"accessid\", accessId);\n            respMap.put(\"policy\", encodedPolicy);\n            respMap.put(\"signature\", postSignature);\n            respMap.put(\"dir\", dir);\n            respMap.put(\"host\", host);\n            respMap.put(\"expire\", String.valueOf(expireEndTime / 1000));\n            // respMap.put(\"expire\", formatISO8601Date(expiration));\n            //跨域、回调直接删除\n\n        } catch (Exception e) {\n            // Assert.fail(e.getMessage());\n            System.out.println(e.getMessage());\n        } finally {\n            ossClient.shutdown();\n        }\n        return R.ok().put(\"data\", respMap);\n    }\n\n    /**\n     * 获取oss文件列表\n     */\n    @GetMapping(\"/list\")\n    public R getOssList() {\n        List<OssEntity> data = ossService.getOssList();\n        return R.ok().put(\"data\", data);\n    }\n\n\n}\n```\n\n如何获取OSS中存储的文件信息，根据官方文档API\n\n```java\n@Value(\"${spring.cloud.alicloud.oss.endpoint}\")\nprivate String endpoint1;\n@Value(\"${spring.cloud.alicloud.oss.bucket}\")\nprivate String bucketName;\n@Value(\"${spring.cloud.alicloud.access-key}\")\nprivate String accessKeyId;\n@Value(\"${spring.cloud.alicloud.secret-key}\")\nprivate String accessKeySecret;\n\n@Override\npublic List<OssEntity> getOssList() {\n    String endpoint = \"http://\" + endpoint1;\n    String prefix = \"http://gulimall-wqs.oss-cn-beijing.aliyuncs.com/\";\n\n    // 创建OSSClient实例。\n    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\n\n   // 列举文件。如果不设置KeyPrefix，则列举存储空间下的所有文件。如果设置KeyPrefix，则列举包含指定前缀的文件。\n    ObjectListing objectListing = ossClient.listObjects(bucketName);\n    List<OSSObjectSummary> sums = objectListing.getObjectSummaries();\n    List<OssEntity> collect = sums.stream().map(item -> {\n        OssEntity ossEntity = new OssEntity();\n        ossEntity.setUrl(prefix + item.getKey());\n        ossEntity.setName(item.getKey());\n        return ossEntity;\n    }).collect(Collectors.toList());\n\n\n    // 关闭OSSClient。\n    ossClient.shutdown();\n    return collect;\n}\n```\n\n', '<p><a href=\"https://gitee.com/thciweicloud/loafblog\">面包博客</a>一直想要高效的管理图片资源，为了节约服务器资源，可以选择阿里云OSS存储，并且它和SpringCloud Alibaba又是天然融合</p>\n<p>服务流程：用户将图片等资源传到服务器，服务器接收处理后再传给我们的阿里云OSS存储，但这样势必会带来大量的流量带宽消耗；所以有了第二种方式，通过policy策略，也就是提前获取签名的方式，将文件资源和签名共同提交给OSS进行验证继而存储，省去了通过服务器的消耗步骤，完成了资源的节约</p>\n<p>下面是代码，以springcloud为例：</p>\n<p>如果你使用了springcloud-gateway，网关会对资源传输的大小进行限制，导致报错，所以要进行相应的配置</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  application:\n    name: loafblog-picture\n  cloud:\n    alicloud:\n      access-key: LTAI5tBKticuE4GnKjdzUmx6\n      secret-key: EAVjuJaAXB9yZLSPV2k4rsbtdq6860\n      oss:\n        endpoint: oss-cn-beijing.aliyuncs.com\n        bucket: gulimall-wqs\n  servlet:    #配置文件阈值    \n   multipart: \n     max-file-size: 10MB\n     max-request-size: 100MB\n</code></pre>\n<pre><code class=\"xml language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alicloud-oss&lt;/artifactId&gt;\n    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<pre><code class=\"java language-java\">@RestController\n@RequestMapping(\"picture\")\npublic class OssController {\n    /**\n     * ossClient这里要使用父类\n     */\n    @Autowired\n    OSS ossClient;\n    @Autowired\n    OssService ossService;\n\n    @Value(\"${spring.cloud.alicloud.oss.endpoint}\")\n    private String endpoint;\n    @Value(\"${spring.cloud.alicloud.oss.bucket}\")\n    private String bucket;\n    @Value(\"${spring.cloud.alicloud.access-key}\")\n    private String accessId;\n\n    @GetMapping(\"/id\")\n    public R test1() {\n        return R.ok().put(\"data\", 1);\n    }\n\n    /**\n     * 签名直接上传到oss\n     *\n     * @return\n     */\n    @RequestMapping(\"/oss/policy\")\n    public R policy() {\n        String host = \"https://\" + bucket + \".\" + endpoint; // host的格式为 bucketname.endpoint\n        // callbackUrl为 上传回调服务器的URL，请将下面的IP和Port配置为您自己的真实信息。\n        //   String callbackUrl = \"http://88.88.88.88:8888\";\n        String format = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n        String dir = format + \"/\"; // 用户上传文件时指定的前缀。\n\n        Map&lt;String, String&gt; respMap = null;\n\n        try {\n            long expireTime = 30;\n            long expireEndTime = System.currentTimeMillis() + expireTime * 1000;\n            Date expiration = new Date(expireEndTime);\n            // PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。\n            PolicyConditions policyConds = new PolicyConditions();\n            policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, 0, 1048576000);\n            policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);\n\n            String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);\n            byte[] binaryData = postPolicy.getBytes(\"utf-8\");\n            String encodedPolicy = BinaryUtil.toBase64String(binaryData);\n            String postSignature = ossClient.calculatePostSignature(postPolicy);\n\n            respMap = new LinkedHashMap&lt;String, String&gt;();\n            respMap.put(\"accessid\", accessId);\n            respMap.put(\"policy\", encodedPolicy);\n            respMap.put(\"signature\", postSignature);\n            respMap.put(\"dir\", dir);\n            respMap.put(\"host\", host);\n            respMap.put(\"expire\", String.valueOf(expireEndTime / 1000));\n            // respMap.put(\"expire\", formatISO8601Date(expiration));\n            //跨域、回调直接删除\n\n        } catch (Exception e) {\n            // Assert.fail(e.getMessage());\n            System.out.println(e.getMessage());\n        } finally {\n            ossClient.shutdown();\n        }\n        return R.ok().put(\"data\", respMap);\n    }\n\n    /**\n     * 获取oss文件列表\n     */\n    @GetMapping(\"/list\")\n    public R getOssList() {\n        List&lt;OssEntity&gt; data = ossService.getOssList();\n        return R.ok().put(\"data\", data);\n    }\n\n\n}\n</code></pre>\n<p>如何获取OSS中存储的文件信息，根据官方文档API</p>\n<pre><code class=\"java language-java\">@Value(\"${spring.cloud.alicloud.oss.endpoint}\")\nprivate String endpoint1;\n@Value(\"${spring.cloud.alicloud.oss.bucket}\")\nprivate String bucketName;\n@Value(\"${spring.cloud.alicloud.access-key}\")\nprivate String accessKeyId;\n@Value(\"${spring.cloud.alicloud.secret-key}\")\nprivate String accessKeySecret;\n\n@Override\npublic List&lt;OssEntity&gt; getOssList() {\n    String endpoint = \"http://\" + endpoint1;\n    String prefix = \"http://gulimall-wqs.oss-cn-beijing.aliyuncs.com/\";\n\n    // 创建OSSClient实例。\n    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);\n\n   // 列举文件。如果不设置KeyPrefix，则列举存储空间下的所有文件。如果设置KeyPrefix，则列举包含指定前缀的文件。\n    ObjectListing objectListing = ossClient.listObjects(bucketName);\n    List&lt;OSSObjectSummary&gt; sums = objectListing.getObjectSummaries();\n    List&lt;OssEntity&gt; collect = sums.stream().map(item -&gt; {\n        OssEntity ossEntity = new OssEntity();\n        ossEntity.setUrl(prefix + item.getKey());\n        ossEntity.setName(item.getKey());\n        return ossEntity;\n    }).collect(Collectors.toList());\n\n\n    // 关闭OSSClient。\n    ossClient.shutdown();\n    return collect;\n}\n</code></pre>', '面包博客一直想要高效的管理图片资源，为了节约服务器资源，可以选择阿里云OSS存储，并且它和SpringCloud Alibaba又是天然融合', 'http://gulimall-wqs.oss-cn-beijing.aliyuncs.com/typora/202301201618526.png', '2023-05-03 17:20:52', 1, 1, 724, 0);
INSERT INTO `article` VALUES (33, 'Git使用', 2, 4, '## 相遇Git\n\n暂时不讨论原理，这里专注于使用 git 这一版本控制工具\n\n\n\n## Git指令\n\n```markdown\n#新建目录(获得.git文件)\ngit init\n#显示分支\ngit branch    一般是--master\ngit branch -r 显示所有远程分支\ngit branch -a 显示所有本地和远程分支\n#新建分支 \ngit branch 名字\n#提交到暂存区\ngit add .\n#提交到仓库\ngit commit -m 文件\n#上传，将本地的分支版本上传到远程并合并\ngit push\n#克隆\ngit clone url \n```\n\n基本操作\n\n```markdown\ngit add . 添加到暂存区\ngit commit 提交\ngit push 上传合并\n```\n\n\n\n## Git项目\n\n### 项目操作\n\n以 idea 为例\n\n懒人方法：我们使用码云作为代码托管仓库，git clone下来文件，将clone下的文件复制（gitignore除外，因为idea会自动生成），直接粘贴进我们的项目文件即可，在项目中使用命令行\n\n```\ngit add . 添加到暂存区\n```\n\n之后点击右上角的commit标志，写好日志，连续commit即可\n\n最后命令行中输入\n\n```\ngit push\n```\n\n\n\n### 版本回退\n\n左下角的git图标我们可以查看我们的版本，如果想要回退到某一版本，打开git 图标找到 log日志\n\n右击我们需要的版本，复制版本号（copy version number），右键左上角整个文件夹 git中选择 reset Head输入版本号（**选择hard类型**）即可回退\n\n回到过去，如何**回到未来**？\n\n```\ngit reflog\n显示之前的版本和日志\ngit reset --hard 版本号 reflog只会显示前几位，也足够了\n```\n\ngit一些详情可见https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '<h2 id=\"git\">相遇Git</h2>\n<p>暂时不讨论原理，这里专注于使用 git 这一版本控制工具</p>\n<h2 id=\"git-1\">Git指令</h2>\n<pre><code class=\"markdown language-markdown\">#新建目录(获得.git文件)\ngit init\n#显示分支\ngit branch    一般是--master\ngit branch -r 显示所有远程分支\ngit branch -a 显示所有本地和远程分支\n#新建分支 \ngit branch 名字\n#提交到暂存区\ngit add .\n#提交到仓库\ngit commit -m 文件\n#上传，将本地的分支版本上传到远程并合并\ngit push\n#克隆\ngit clone url \n</code></pre>\n<p>基本操作</p>\n<pre><code class=\"markdown language-markdown\">git add . 添加到暂存区\ngit commit 提交\ngit push 上传合并\n</code></pre>\n<h2 id=\"git-2\">Git项目</h2>\n<h3 id=\"\">项目操作</h3>\n<p>以 idea 为例</p>\n<p>懒人方法：我们使用码云作为代码托管仓库，git clone下来文件，将clone下的文件复制（gitignore除外，因为idea会自动生成），直接粘贴进我们的项目文件即可，在项目中使用命令行</p>\n<pre><code>git add . 添加到暂存区\n</code></pre>\n<p>之后点击右上角的commit标志，写好日志，连续commit即可</p>\n<p>最后命令行中输入</p>\n<pre><code>git push\n</code></pre>\n<h3 id=\"-1\">版本回退</h3>\n<p>左下角的git图标我们可以查看我们的版本，如果想要回退到某一版本，打开git 图标找到 log日志</p>\n<p>右击我们需要的版本，复制版本号（copy version number），右键左上角整个文件夹 git中选择 reset Head输入版本号（<strong>选择hard类型</strong>）即可回退</p>\n<p>回到过去，如何<strong>回到未来</strong>？</p>\n<pre><code>git reflog\n显示之前的版本和日志\ngit reset --hard 版本号 reflog只会显示前几位，也足够了\n</code></pre>\n<p>git一些详情可见https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192</p>', '暂时不讨论原理，这里专注于使用 git 这一版本控制工具', 'http://gulimall-wqs.oss-cn-beijing.aliyuncs.com/2022-12-31/4509c0f7-72f5-4eda-8806-628bec4e8665_1.jpg', '2023-05-03 17:33:07', 1, 1, 432, 0);
INSERT INTO `article` VALUES (34, 'MyBatis-Plus学习笔记', 4, 8, '国产的开源框架，基于 MyBatis\n\n核心功能就是简化 MyBatis 的开发，提高效率。\n\n### MyBatis Plus 快速上手\n\n1、创建 Maven 工程\n\n2、pom.xml 引入 MyBatis Plus 的依赖\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-boot-starter</artifactId>\n    <version>3.3.1.tmp</version>\n</dependency>\n```\n\n3、创建实体类\n\n```java\nimport lombok.Data;\n\n@Data\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n}\n```\n\n4、创建 Mapper 接口\n\n```java\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.southwind.mybatisplus.entity.User;\n\npublic interface UserMapper extends BaseMapper<User> {\n\n}\n```\n\n5、application.yml\n\n```yaml\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/db?useUnicode=true&characterEncoding=UTF-8\n    username: root\n    password: root\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n```\n\n6、启动类需要添加 @MapperScan(\"mapper所在的包\")，否则无法加载 Mppaer bean。\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.southwind.mybatisplus.mapper\")\npublic class MybatisplusApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MybatisplusApplication.class, args);\n    }\n\n}\n```\n\n7、测试\n\n```java\n@SpringBootTest\nclass UserMapperTest {\n\n    @Autowired\n    private UserMapper mapper;\n\n    @Test\n    void test(){\n        mapper.selectList(null).forEach(System.out::println);\n    }\n\n}\n```\n\n\n\n### 常用注解\n\n> @TableName\n\n映射数据库的表名\n\n```java\n@Data\n@TableName(value = \"user\")\npublic class Account {\n    private Integer id;\n    private String name;\n    private Integer age;\n}\n```\n\n\n\n> @TableId\n\n设置主键映射，value 映射主键字段名\n\ntype 设置主键类型，主键的生成策略，\n\n```java\nAUTO(0),\nNONE(1),\nINPUT(2),\nASSIGN_ID(3),\nASSIGN_UUID(4),\n/** @deprecated */\n@Deprecated\nID_WORKER(3),\n/** @deprecated */\n@Deprecated\nID_WORKER_STR(3),\n/** @deprecated */\n@Deprecated\nUUID(4);\n```\n\n| 值          | 描述                              |\n| ----------- | --------------------------------- |\n| AUTO        | 数据库自增                        |\n| NONE        | MP set 主键，雪花算法实现         |\n| INPUT       | 需要开发者手动赋值                |\n| ASSIGN_ID   | MP 分配 ID，Long、Integer、String |\n| ASSIGN_UUID | 分配 UUID，Strinig                |\n\nINPUT 如果开发者没有手动赋值，则数据库通过自增的方式给主键赋值，如果开发者手动赋值，则存入该值。\n\nAUTO 默认就是数据库自增，开发者无需赋值。\n\nASSIGN_ID MP 自动赋值，雪花算法。\n\nASSIGN_UUID 主键的数据类型必须是 String，自动生成 UUID 进行赋值\n\n\n\n> @TableField\n\n映射非主键字段，value 映射字段名\n\nexist 表示是否为数据库字段 false，如果实体类中的成员变量在数据库中没有对应的字段，则可以使用 exist，VO、DTO\n\nselect 表示是否查询该字段\n\nfill 表示是否自动填充，将对象存入数据库的时候，由 MyBatis Plus 自动给某些字段赋值，create_time、update_time\n\n1、给表添加 create_time、update_time 字段\n\n2、实体类中添加成员变量\n\n```java\n@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private Integer age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n}\n```\n\n3、创建自动填充处理器\n\n```java\nimport com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        this.setFieldValByName(\"createTime\",new Date(),metaObject);\n        this.setFieldValByName(\"updateTime\",new Date(),metaObject);\n    }\n\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        this.setFieldValByName(\"updateTime\",new Date(),metaObject);\n    }\n}\n```\n\n\n\n> @Version\n\n标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据的时候，会以 version 作为条件，当条件成立的时候才会修改成功。\n\nversion = 2\n\n线程 1:update ... set version = 2  where version = 1\n\n线程2 ：update ... set version = 2 where version = 1\n\n1、数据库表添加 version 字段，默认值为 1\n\n2、实体类添加 version 成员变量，并且添加 @Version \n\n```java\nimport com.baomidou.mybatisplus.annotation.*;\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private Integer age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n    @Version\n    private Integer version;\n}\n```\n\n3、注册配置类\n\n```java\npackage com.southwind.mybatisplus.config;\n\nimport com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MyBatisPlusConfig {\n    \n    @Bean\n    public OptimisticLockerInterceptor optimisticLockerInterceptor(){\n        return new OptimisticLockerInterceptor();\n    }\n    \n}\n```\n\n逻辑控制\n\n==>  Preparing: UPDATE user SET name=?, age=?, update_time=?, version=? WHERE id=? AND version=? \n==> Parameters: 二号(String), 11(Integer), 2021-04-29 09:32:15.734(Timestamp), 3(Integer), 5(Integer), 2(Integer)\n<==    Updates: 1\n\n\n\n==> Parameters: 一号(String), 11(Integer), 2021-04-29 09:32:15.747(Timestamp), 3(Integer), 5(Integer), 2(Integer)\n<==    Updates: 0\n\n> @EnumValue\n\n1、通用枚举类注解，将数据库字段映射成实体类的枚举类型成员变量\n\n```java\nimport com.baomidou.mybatisplus.annotation.EnumValue;\n\npublic enum StatusEnum {\n    WORK(1,\"上班\"),\n    REST(0,\"休息\");\n\n    StatusEnum(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    @EnumValue\n    private Integer code;\n    private String msg;\n}\n```\n\n```java\nimport com.baomidou.mybatisplus.annotation.*;\nimport com.southwind.mybatisplus.enums.StatusEnum;\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private Integer age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n    @Version\n    private Integer version;\n    private StatusEnum status;\n}\n```\n\napplication.yml\n\n```yaml\ntype-enums-package: \n  com.southwind.mybatisplus.enums\n```\n\n2、实现接口\n\n```java\nimport com.baomidou.mybatisplus.core.enums.IEnum;\n\npublic enum AgeEnum implements IEnum<Integer> {\n    ONE(1,\"一岁\"),\n    TWO(2,\"两岁\"),\n    THREE(3,\"三岁\");\n\n    private Integer code;\n    private String msg;\n\n    AgeEnum(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    @Override\n    public Integer getValue() {\n        return this.code;\n    }\n}\n```\n\n\n\n> @TableLogic\n\n映射逻辑删除\n\n1、数据表添加 deleted 字段\n\n2、实体类添加注解\n\n```java\nimport com.baomidou.mybatisplus.annotation.*;\nimport com.southwind.mybatisplus.enums.AgeEnum;\nimport com.southwind.mybatisplus.enums.StatusEnum;\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private AgeEnum age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n    @Version\n    private Integer version;\n    @TableField(value = \"status\")\n    private StatusEnum statusEnum;\n    @TableLogic\n    private Integer deleted;\n}\n```\n\n3、application.yml 添加配置\n\n```yaml\nglobal-config:\n  db-config:\n    logic-not-delete-value: 0\n    logic-delete-value: 1\n```\n\n逻辑删除其实是mybatis-plus帮你封装了此语句\n\n查询时逻辑\n\n Preparing: SELECT id,name,age,create_time,update_time,version,status,deleted FROM user WHERE deleted=0 \n\n### 查询\n\n模糊查询\n\n```java\nwrapper.like(\"name\",\"%\");\nuserMapper.selectList(wrapper);\n```\n\n```java\n  @Test\n    void select() {\n        //不加任何条件全部查询\n        //userMapper.selectList(null);\n        QueryWrapper wrapper = new QueryWrapper();\n//        wrapper.eq(\"name\",\"张三\");\n//        System.out.println(userMapper.selectList(wrapper));\n        //逻辑条件查询\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"name\", \"张三\");\n        map.put(\"age\", 1);\n//        wrapper.allEq(map);\n//        System.out.println(userMapper.selectList(wrapper));\n//        //大于\n//        wrapper.gt(\"age\",3);\n////        System.out.println(userMapper.selectList(wrapper));\n//        //小于\n//        wrapper.lt(\"age\",11);\n//        //大于等于\n//        wrapper.ge(\"age\",12);\n\n        //模糊查询 \'%张%\' \'张%\' \'%张\'\n//        wrapper.like(\"name\",\"张\");\n//        wrapper.likeRight(\"name\",\"张\");\n//        wrapper.likeLeft(\"name\",\"张\");\n\n        //联合查询=>嵌套查询\n//        wrapper.inSql(\"id\",\"select id from user where id<10\");\n//        wrapper.inSql(\"age\",\"select age from user where age>3\");\n\n        //order by\n//        wrapper.orderByDesc(\"age\");\n        wrapper.orderByAsc(\"age\");\n        wrapper.having(\"id>3\");\n        System.out.println(userMapper.selectList(wrapper));\n    }\n```\n\n```java\n@Test\n    void select1() {\n        //System.out.println(userMapper.selectById(6));\n        //id集合ById查询\n        // userMapper.selectBatchIds(Arrays.asList(4,5,6)).forEach(System.out::println);\n\n        //Map 只能做等值判断，逻辑判断还是用wrapper来处理\n//        Map<String,Object> map=new HashMap<>();\n//        map.put(\"id\",6);\n//        userMapper.selectByMap(map).forEach(System.out::println);\n\n        QueryWrapper wrapper = new QueryWrapper();\n        wrapper.gt(\"age\", 1);\n//        System.out.println(userMapper.selectCount(wrapper));\n\n        //将查询到的结果集封装到map中\n        userMapper.selectMaps(wrapper).forEach(System.out::println);\n        System.out.println(\"-----------------------\");\n        userMapper.selectList(wrapper).forEach(System.out::println);\n        //分页查询\n//        Page<User> page=new Page<>(1,2);\n//        Page<User> result = userMapper.selectPage(page, null);\n//        System.out.println(result.getSize());\n//        System.out.println(result.getTotal());\n//        result.getRecords().forEach(System.out::println);\n\n        //得到map集合封装的结果\n//        Page<Map<String,Object>> page=new Page<>(1,2);\n//        userMapper.selectMapsPage(page,null).getRecords().forEach(System.out::println);\n\n        //所有对象id\n        userMapper.selectObjs(null).forEach(System.out::println);\n\n        wrapper.eq(\"id\", 6);\n        System.out.println(userMapper.selectOne(wrapper));\n\n\n    }\n```\n\n### 自定义 SQL（多表关联查询）\n\n```java\npackage com.southwind.mybatisplus.entity;\n\nimport lombok.Data;\n\n@Data\npublic class ProductVO {\n    private Integer category;\n    private Integer count;\n    private String description;\n    private Integer userId;\n    private String userName;\n}\n```\n\n```java\npackage com.southwind.mybatisplus.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.southwind.mybatisplus.entity.ProductVO;\nimport com.southwind.mybatisplus.entity.User;\nimport org.apache.ibatis.annotations.Select;\n\nimport java.util.List;\n\npublic interface UserMapper extends BaseMapper<User> {\n    @Select(\"select p.*,u.name userName from product p,user u where p.user_id = u.id and u.id = #{id}\")\n    List<ProductVO> productList(Integer id);\n}\n```\n\n\n\n### 添加\n\n```java\nUser user = new User();\nuser.setTitle(\"小明\");\nuser.setAge(22);\nmapper.insert(user);\nSystem.out.println(user);\n```\n\n\n\n### 删除\n\n```java\n @Test\n    void delete() {\n        userMapper.deleteById(7);\n        userMapper.deleteBatchIds(Arrays.asList(8, 9));\n        QueryWrapper wrapper = new QueryWrapper();\n        wrapper.eq(\"age\", 11);\n        userMapper.delete(wrapper);\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id\", 8);\n        userMapper.deleteByMap(map);\n\n    }\n```\n\n\n\n### 修改\n\n```java\n    @Test\n    void update() {\n        //update .. version=3 where version=2\n        User user = userMapper.selectById(5);\n        user.setName(\"一号\");\n        //update .. version=3 where version=2\n        User user1 = userMapper.selectById(5);\n        user1.setName(\"二号\");\n        userMapper.updateById(user1);\n        userMapper.updateById(user);\n\n        User user2 = userMapper.selectById(8);\n        user2.setName(\"文谦\");\n        QueryWrapper wrapper = new QueryWrapper();\n        wrapper.eq(\"age\", 7);\n        userMapper.update(user2, wrapper);\n    }\n```\n\n\n\n### 代码生成器\n\n根据数据表自动生成entity、Mapper、Service、ServiceImpl、Controller（不想要的可以不使用set）\n\n1、pom.xml 导入 MyBatis Plus Generator\n\n```xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>mybatis-plus-generator</artifactId>\n    <version>3.3.1.tmp</version>\n</dependency>\n<!--默认根据模板生成-->\n<dependency>\n    <groupId>org.apache.velocity</groupId>\n    <artifactId>velocity</artifactId>\n    <version>1.7</version>\n</dependency>\n```\n\nVelocity（默认）、Freemarker、Beetl\n\n2、启动类\n\n创建Main类作为另一个启动类\n\n```java\npackage com.thciwei.mybatisplus;\n\nimport com.baomidou.mybatisplus.annotation.DbType;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;\nimport com.baomidou.mybatisplus.generator.config.GlobalConfig;\nimport com.baomidou.mybatisplus.generator.config.PackageConfig;\nimport com.baomidou.mybatisplus.generator.config.StrategyConfig;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\n\nimport javax.sql.DataSource;\n\npublic class Main {\n    public static void main(String[] args) {\n        //创建generator对象\n        AutoGenerator autoGenerator = new AutoGenerator();\n        //数据源\n        DataSourceConfig dataSourceConfig = new DataSourceConfig();\n        dataSourceConfig.setDbType(DbType.MYSQL);\n        dataSourceConfig.setUrl(\"jdbc:mysql://localhost:3306/test?useUnicode=true&&characterEncoding=UTF-8\");\n        dataSourceConfig.setUsername(\"root\");\n        dataSourceConfig.setPassword(\"thciwei\");\n        dataSourceConfig.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        autoGenerator.setDataSource(dataSourceConfig);\n        //全局配置\n        GlobalConfig globalConfig = new GlobalConfig();\n        globalConfig.setOutputDir(System.getProperty(\"user.dir\") + \"/src/main/java\");\n        globalConfig.setOpen(false);\n        globalConfig.setAuthor(\"thciwei\");\n        globalConfig.setServiceName(\"%sService\");\n        autoGenerator.setGlobalConfig(globalConfig);\n        //包信息\n        PackageConfig packageConfig = new PackageConfig();\n        packageConfig.setParent(\"com.thciwei.mybatisplus\");\n        packageConfig.setModuleName(\"generator\");\n        packageConfig.setController(\"controller\");\n        packageConfig.setService(\"service\");\n        packageConfig.setServiceImpl(\"serviceImpl\");\n        packageConfig.setMapper(\"mapper\");\n        packageConfig.setEntity(\"entity\");\n        autoGenerator.setPackageInfo(packageConfig);\n        //配置策略\n        StrategyConfig strategyConfig = new StrategyConfig();\n        strategyConfig.setEntityLombokModel(true);\n        strategyConfig.setNaming(NamingStrategy.underline_to_camel);\n        strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);\n        autoGenerator.setStrategy(strategyConfig);\n\n        autoGenerator.execute();\n    }\n}\n\n```\n\n\n\n', '<p>国产的开源框架，基于 MyBatis</p>\n<p>核心功能就是简化 MyBatis 的开发，提高效率。</p>\n<h3 id=\"mybatisplus\">MyBatis Plus 快速上手</h3>\n<p>1、创建 Maven 工程</p>\n<p>2、pom.xml 引入 MyBatis Plus 的依赖</p>\n<pre><code class=\"xml language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;3.3.1.tmp&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>3、创建实体类</p>\n<pre><code class=\"java language-java\">import lombok.Data;\n\n@Data\npublic class User {\n    private Integer id;\n    private String name;\n    private Integer age;\n}\n</code></pre>\n<p>4、创建 Mapper 接口</p>\n<pre><code class=\"java language-java\">import com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.southwind.mybatisplus.entity.User;\n\npublic interface UserMapper extends BaseMapper&lt;User&gt; {\n\n}\n</code></pre>\n<p>5、application.yml</p>\n<pre><code class=\"yaml language-yaml\">spring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/db?useUnicode=true&amp;characterEncoding=UTF-8\n    username: root\n    password: root\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n</code></pre>\n<p>6、启动类需要添加 @MapperScan(\"mapper所在的包\")，否则无法加载 Mppaer bean。</p>\n<pre><code class=\"java language-java\">@SpringBootApplication\n@MapperScan(\"com.southwind.mybatisplus.mapper\")\npublic class MybatisplusApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(MybatisplusApplication.class, args);\n    }\n\n}\n</code></pre>\n<p>7、测试</p>\n<pre><code class=\"java language-java\">@SpringBootTest\nclass UserMapperTest {\n\n    @Autowired\n    private UserMapper mapper;\n\n    @Test\n    void test(){\n        mapper.selectList(null).forEach(System.out::println);\n    }\n\n}\n</code></pre>\n<h3 id=\"\">常用注解</h3>\n<blockquote>\n  <p>@TableName</p>\n</blockquote>\n<p>映射数据库的表名</p>\n<pre><code class=\"java language-java\">@Data\n@TableName(value = \"user\")\npublic class Account {\n    private Integer id;\n    private String name;\n    private Integer age;\n}\n</code></pre>\n<blockquote>\n  <p>@TableId</p>\n</blockquote>\n<p>设置主键映射，value 映射主键字段名</p>\n<p>type 设置主键类型，主键的生成策略，</p>\n<pre><code class=\"java language-java\">AUTO(0),\nNONE(1),\nINPUT(2),\nASSIGN_ID(3),\nASSIGN_UUID(4),\n/** @deprecated */\n@Deprecated\nID_WORKER(3),\n/** @deprecated */\n@Deprecated\nID_WORKER_STR(3),\n/** @deprecated */\n@Deprecated\nUUID(4);\n</code></pre>\n<p>| 值          | 描述                              |\n| ----------- | --------------------------------- |\n| AUTO        | 数据库自增                        |\n| NONE        | MP set 主键，雪花算法实现         |\n| INPUT       | 需要开发者手动赋值                |\n| ASSIGN<em>ID   | MP 分配 ID，Long、Integer、String |\n| ASSIGN</em>UUID | 分配 UUID，Strinig                |</p>\n<p>INPUT 如果开发者没有手动赋值，则数据库通过自增的方式给主键赋值，如果开发者手动赋值，则存入该值。</p>\n<p>AUTO 默认就是数据库自增，开发者无需赋值。</p>\n<p>ASSIGN_ID MP 自动赋值，雪花算法。</p>\n<p>ASSIGN_UUID 主键的数据类型必须是 String，自动生成 UUID 进行赋值</p>\n<blockquote>\n  <p>@TableField</p>\n</blockquote>\n<p>映射非主键字段，value 映射字段名</p>\n<p>exist 表示是否为数据库字段 false，如果实体类中的成员变量在数据库中没有对应的字段，则可以使用 exist，VO、DTO</p>\n<p>select 表示是否查询该字段</p>\n<p>fill 表示是否自动填充，将对象存入数据库的时候，由 MyBatis Plus 自动给某些字段赋值，create<em>time、update</em>time</p>\n<p>1、给表添加 create<em>time、update</em>time 字段</p>\n<p>2、实体类中添加成员变量</p>\n<pre><code class=\"java language-java\">@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private Integer age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n}\n</code></pre>\n<p>3、创建自动填充处理器</p>\n<pre><code class=\"java language-java\">import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;\nimport org.apache.ibatis.reflection.MetaObject;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        this.setFieldValByName(\"createTime\",new Date(),metaObject);\n        this.setFieldValByName(\"updateTime\",new Date(),metaObject);\n    }\n\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        this.setFieldValByName(\"updateTime\",new Date(),metaObject);\n    }\n}\n</code></pre>\n<blockquote>\n  <p>@Version</p>\n</blockquote>\n<p>标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据的时候，会以 version 作为条件，当条件成立的时候才会修改成功。</p>\n<p>version = 2</p>\n<p>线程 1:update … set version = 2  where version = 1</p>\n<p>线程2 ：update … set version = 2 where version = 1</p>\n<p>1、数据库表添加 version 字段，默认值为 1</p>\n<p>2、实体类添加 version 成员变量，并且添加 @Version </p>\n<pre><code class=\"java language-java\">import com.baomidou.mybatisplus.annotation.*;\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private Integer age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n    @Version\n    private Integer version;\n}\n</code></pre>\n<p>3、注册配置类</p>\n<pre><code class=\"java language-java\">package com.southwind.mybatisplus.config;\n\nimport com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MyBatisPlusConfig {\n\n    @Bean\n    public OptimisticLockerInterceptor optimisticLockerInterceptor(){\n        return new OptimisticLockerInterceptor();\n    }\n\n}\n</code></pre>\n<p>逻辑控制</p>\n<p>==&gt;  Preparing: UPDATE user SET name=?, age=?, update_time=?, version=? WHERE id=? AND version=? \n==&gt; Parameters: 二号(String), 11(Integer), 2021-04-29 09:32:15.734(Timestamp), 3(Integer), 5(Integer), 2(Integer)\n&lt;==    Updates: 1</p>\n<p>==&gt; Parameters: 一号(String), 11(Integer), 2021-04-29 09:32:15.747(Timestamp), 3(Integer), 5(Integer), 2(Integer)\n&lt;==    Updates: 0</p>\n<blockquote>\n  <p>@EnumValue</p>\n</blockquote>\n<p>1、通用枚举类注解，将数据库字段映射成实体类的枚举类型成员变量</p>\n<pre><code class=\"java language-java\">import com.baomidou.mybatisplus.annotation.EnumValue;\n\npublic enum StatusEnum {\n    WORK(1,\"上班\"),\n    REST(0,\"休息\");\n\n    StatusEnum(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    @EnumValue\n    private Integer code;\n    private String msg;\n}\n</code></pre>\n<pre><code class=\"java language-java\">import com.baomidou.mybatisplus.annotation.*;\nimport com.southwind.mybatisplus.enums.StatusEnum;\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private Integer age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n    @Version\n    private Integer version;\n    private StatusEnum status;\n}\n</code></pre>\n<p>application.yml</p>\n<pre><code class=\"yaml language-yaml\">type-enums-package: \n  com.southwind.mybatisplus.enums\n</code></pre>\n<p>2、实现接口</p>\n<pre><code class=\"java language-java\">import com.baomidou.mybatisplus.core.enums.IEnum;\n\npublic enum AgeEnum implements IEnum&lt;Integer&gt; {\n    ONE(1,\"一岁\"),\n    TWO(2,\"两岁\"),\n    THREE(3,\"三岁\");\n\n    private Integer code;\n    private String msg;\n\n    AgeEnum(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    @Override\n    public Integer getValue() {\n        return this.code;\n    }\n}\n</code></pre>\n<blockquote>\n  <p>@TableLogic</p>\n</blockquote>\n<p>映射逻辑删除</p>\n<p>1、数据表添加 deleted 字段</p>\n<p>2、实体类添加注解</p>\n<pre><code class=\"java language-java\">import com.baomidou.mybatisplus.annotation.*;\nimport com.southwind.mybatisplus.enums.AgeEnum;\nimport com.southwind.mybatisplus.enums.StatusEnum;\nimport lombok.Data;\n\nimport java.util.Date;\n\n@Data\n@TableName(value = \"user\")\npublic class User {\n    @TableId\n    private String id;\n    @TableField(value = \"name\",select = false)\n    private String title;\n    private AgeEnum age;\n    @TableField(exist = false)\n    private String gender;\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n    @Version\n    private Integer version;\n    @TableField(value = \"status\")\n    private StatusEnum statusEnum;\n    @TableLogic\n    private Integer deleted;\n}\n</code></pre>\n<p>3、application.yml 添加配置</p>\n<pre><code class=\"yaml language-yaml\">global-config:\n  db-config:\n    logic-not-delete-value: 0\n    logic-delete-value: 1\n</code></pre>\n<p>逻辑删除其实是mybatis-plus帮你封装了此语句</p>\n<p>查询时逻辑</p>\n<p>Preparing: SELECT id,name,age,create<em>time,update</em>time,version,status,deleted FROM user WHERE deleted=0 </p>\n<h3 id=\"-1\">查询</h3>\n<p>模糊查询</p>\n<pre><code class=\"java language-java\">wrapper.like(\"name\",\"%\");\nuserMapper.selectList(wrapper);\n</code></pre>\n<pre><code class=\"java language-java\">  @Test\n    void select() {\n        //不加任何条件全部查询\n        //userMapper.selectList(null);\n        QueryWrapper wrapper = new QueryWrapper();\n//        wrapper.eq(\"name\",\"张三\");\n//        System.out.println(userMapper.selectList(wrapper));\n        //逻辑条件查询\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(\"name\", \"张三\");\n        map.put(\"age\", 1);\n//        wrapper.allEq(map);\n//        System.out.println(userMapper.selectList(wrapper));\n//        //大于\n//        wrapper.gt(\"age\",3);\n////        System.out.println(userMapper.selectList(wrapper));\n//        //小于\n//        wrapper.lt(\"age\",11);\n//        //大于等于\n//        wrapper.ge(\"age\",12);\n\n        //模糊查询 \'%张%\' \'张%\' \'%张\'\n//        wrapper.like(\"name\",\"张\");\n//        wrapper.likeRight(\"name\",\"张\");\n//        wrapper.likeLeft(\"name\",\"张\");\n\n        //联合查询=&gt;嵌套查询\n//        wrapper.inSql(\"id\",\"select id from user where id&lt;10\");\n//        wrapper.inSql(\"age\",\"select age from user where age&gt;3\");\n\n        //order by\n//        wrapper.orderByDesc(\"age\");\n        wrapper.orderByAsc(\"age\");\n        wrapper.having(\"id&gt;3\");\n        System.out.println(userMapper.selectList(wrapper));\n    }\n</code></pre>\n<pre><code class=\"java language-java\">@Test\n    void select1() {\n        //System.out.println(userMapper.selectById(6));\n        //id集合ById查询\n        // userMapper.selectBatchIds(Arrays.asList(4,5,6)).forEach(System.out::println);\n\n        //Map 只能做等值判断，逻辑判断还是用wrapper来处理\n//        Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();\n//        map.put(\"id\",6);\n//        userMapper.selectByMap(map).forEach(System.out::println);\n\n        QueryWrapper wrapper = new QueryWrapper();\n        wrapper.gt(\"age\", 1);\n//        System.out.println(userMapper.selectCount(wrapper));\n\n        //将查询到的结果集封装到map中\n        userMapper.selectMaps(wrapper).forEach(System.out::println);\n        System.out.println(\"-----------------------\");\n        userMapper.selectList(wrapper).forEach(System.out::println);\n        //分页查询\n//        Page&lt;User&gt; page=new Page&lt;&gt;(1,2);\n//        Page&lt;User&gt; result = userMapper.selectPage(page, null);\n//        System.out.println(result.getSize());\n//        System.out.println(result.getTotal());\n//        result.getRecords().forEach(System.out::println);\n\n        //得到map集合封装的结果\n//        Page&lt;Map&lt;String,Object&gt;&gt; page=new Page&lt;&gt;(1,2);\n//        userMapper.selectMapsPage(page,null).getRecords().forEach(System.out::println);\n\n        //所有对象id\n        userMapper.selectObjs(null).forEach(System.out::println);\n\n        wrapper.eq(\"id\", 6);\n        System.out.println(userMapper.selectOne(wrapper));\n\n\n    }\n</code></pre>\n<h3 id=\"sql\">自定义 SQL（多表关联查询）</h3>\n<pre><code class=\"java language-java\">package com.southwind.mybatisplus.entity;\n\nimport lombok.Data;\n\n@Data\npublic class ProductVO {\n    private Integer category;\n    private Integer count;\n    private String description;\n    private Integer userId;\n    private String userName;\n}\n</code></pre>\n<pre><code class=\"java language-java\">package com.southwind.mybatisplus.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.southwind.mybatisplus.entity.ProductVO;\nimport com.southwind.mybatisplus.entity.User;\nimport org.apache.ibatis.annotations.Select;\n\nimport java.util.List;\n\npublic interface UserMapper extends BaseMapper&lt;User&gt; {\n    @Select(\"select p.*,u.name userName from product p,user u where p.user_id = u.id and u.id = #{id}\")\n    List&lt;ProductVO&gt; productList(Integer id);\n}\n</code></pre>\n<h3 id=\"-2\">添加</h3>\n<pre><code class=\"java language-java\">User user = new User();\nuser.setTitle(\"小明\");\nuser.setAge(22);\nmapper.insert(user);\nSystem.out.println(user);\n</code></pre>\n<h3 id=\"-3\">删除</h3>\n<pre><code class=\"java language-java\"> @Test\n    void delete() {\n        userMapper.deleteById(7);\n        userMapper.deleteBatchIds(Arrays.asList(8, 9));\n        QueryWrapper wrapper = new QueryWrapper();\n        wrapper.eq(\"age\", 11);\n        userMapper.delete(wrapper);\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(\"id\", 8);\n        userMapper.deleteByMap(map);\n\n    }\n</code></pre>\n<h3 id=\"-4\">修改</h3>\n<pre><code class=\"java language-java\">    @Test\n    void update() {\n        //update .. version=3 where version=2\n        User user = userMapper.selectById(5);\n        user.setName(\"一号\");\n        //update .. version=3 where version=2\n        User user1 = userMapper.selectById(5);\n        user1.setName(\"二号\");\n        userMapper.updateById(user1);\n        userMapper.updateById(user);\n\n        User user2 = userMapper.selectById(8);\n        user2.setName(\"文谦\");\n        QueryWrapper wrapper = new QueryWrapper();\n        wrapper.eq(\"age\", 7);\n        userMapper.update(user2, wrapper);\n    }\n</code></pre>\n<h3 id=\"-5\">代码生成器</h3>\n<p>根据数据表自动生成entity、Mapper、Service、ServiceImpl、Controller（不想要的可以不使用set）</p>\n<p>1、pom.xml 导入 MyBatis Plus Generator</p>\n<pre><code class=\"xml language-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;\n    &lt;version&gt;3.3.1.tmp&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--默认根据模板生成--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;\n    &lt;artifactId&gt;velocity&lt;/artifactId&gt;\n    &lt;version&gt;1.7&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Velocity（默认）、Freemarker、Beetl</p>\n<p>2、启动类</p>\n<p>创建Main类作为另一个启动类</p>\n<pre><code class=\"java language-java\">package com.thciwei.mybatisplus;\n\nimport com.baomidou.mybatisplus.annotation.DbType;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.config.DataSourceConfig;\nimport com.baomidou.mybatisplus.generator.config.GlobalConfig;\nimport com.baomidou.mybatisplus.generator.config.PackageConfig;\nimport com.baomidou.mybatisplus.generator.config.StrategyConfig;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\n\nimport javax.sql.DataSource;\n\npublic class Main {\n    public static void main(String[] args) {\n        //创建generator对象\n        AutoGenerator autoGenerator = new AutoGenerator();\n        //数据源\n        DataSourceConfig dataSourceConfig = new DataSourceConfig();\n        dataSourceConfig.setDbType(DbType.MYSQL);\n        dataSourceConfig.setUrl(\"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;&amp;characterEncoding=UTF-8\");\n        dataSourceConfig.setUsername(\"root\");\n        dataSourceConfig.setPassword(\"thciwei\");\n        dataSourceConfig.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        autoGenerator.setDataSource(dataSourceConfig);\n        //全局配置\n        GlobalConfig globalConfig = new GlobalConfig();\n        globalConfig.setOutputDir(System.getProperty(\"user.dir\") + \"/src/main/java\");\n        globalConfig.setOpen(false);\n        globalConfig.setAuthor(\"thciwei\");\n        globalConfig.setServiceName(\"%sService\");\n        autoGenerator.setGlobalConfig(globalConfig);\n        //包信息\n        PackageConfig packageConfig = new PackageConfig();\n        packageConfig.setParent(\"com.thciwei.mybatisplus\");\n        packageConfig.setModuleName(\"generator\");\n        packageConfig.setController(\"controller\");\n        packageConfig.setService(\"service\");\n        packageConfig.setServiceImpl(\"serviceImpl\");\n        packageConfig.setMapper(\"mapper\");\n        packageConfig.setEntity(\"entity\");\n        autoGenerator.setPackageInfo(packageConfig);\n        //配置策略\n        StrategyConfig strategyConfig = new StrategyConfig();\n        strategyConfig.setEntityLombokModel(true);\n        strategyConfig.setNaming(NamingStrategy.underline_to_camel);\n        strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);\n        autoGenerator.setStrategy(strategyConfig);\n\n        autoGenerator.execute();\n    }\n}\n</code></pre>', 'ORM框架，基本使用方法', 'http://8.129.122.160/group1/M00/00/00/CIF6oGOu4vOAbM8sAAEXTrmt-34540.jpg', '2023-05-03 17:34:11', 1, 1, 1872, 0);
INSERT INTO `article` VALUES (35, 'Docker的基本使用', 7, 5, '## Docker 命令\n\n```shell\n# 查看镜像|搜索|删除\n检查版本：docker --version             \n\n检查镜像是否生效:docker info                    \n\n查看镜像：docker images\n\n搜索镜像：docker search mysql:5.7.0 (5.7.0：搜索指定的版本)\n\n列出当前运行的容器：docker ps\n\n删除：docker rmi 容器id/mysql:版本号       \n\n强制删除：docker rmi 容器id -f   简写rm也可以\n\ndocker rmi -f $(docker images 镜像名 -q)\n\nctrl c 结束\n```\n\n### 一般步骤\n\n```shell\ndocker pull nginx\ndocker images\ndocker run -d -p 80:80 --name xx nginx  \ndocker ps\n{\ndocker ps -a 历史运行\ndocker rm 容器id 可删除历史中的容器\n}\ndocker ps\ndocker exec -it 容器id /bin/bash 进入容器进行交互\ncd /usr/share/nginx/html/\nls\n(xxxx index.html)\necho \"i love java\" > index.html\ncat index.html       --i love java\ndocker commit 容器id lovenginx:1.11  上传自己修改的镜像\ndocker images\ndocker stop 容器id\ndocker ps\ndocker rm $(docker ps -qa)     删除所有运行\ndocker run -d -p 80:80 容器id   运行自己的镜像，须通过id\ndocker ps    \n```\n\n**ctrl insert复制**\n\n**shift insert 粘贴**\n\n---\n\n## 容器\n\n一个镜像是一个应用环境\n\n### 外部指令\n\n```shell\n# 运行容器\n\n启动应用：docker run  mysql\n\n-d 启动守护式容器(在后台启动容器，不占用窗口)\n--name 起别名\n-p 映射端口：原始端口号    指定端口号启动\n-P 随机分配端口\n\n例:不占用窗口并映射访问路径：docker run -d -p 80:80 mysql\n\n自定义名称：docker run -d -p 80:80 --name mynginx nginx\n# 查看运行容器\n查看运行容器：docker ps\n\n显示所有容器：docker ps -a\n-a 显示正在运行和历史运行\n-q 静默模式，只显示容器编号\n一起用：docker ps -qa \n\n# 停止|关闭\n开启容器：docker start 容器名字或者id\n重启容器：docker restart 容器名字或者id\n结束容器：docker stop 对应的id\n立即停止容器：docker kill id\n\n# 删除容器\n删除容器：docker rm id\n强制删除：docker rm id -f\n删除所有：docker rm -f $(docker ps -qa)\n\n# 删除镜像\ndocker ps -a 查看容器id\ndocker rmi 容器id ，先删除容器再删除镜像\ndocker rm -f 镜像id\n\n# 挂载文件目录\ndocker run -d -p 9090:9090 --name prometheus -v linux地址:容器内地址   bitnami/prometheus:latest \n如挂载多个使用 \\ 作为换行符 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n\n# 设置容器自启动\ndocker update redis --restart=always\n```\n\n### 内部指令\n\n```shell\n# 查看容器内进程\n查看容器内的进程：docker top 容器id或容器name\n\n# 查看容器内部细节 \n查看内部细节：docker inspect 容器id\n\n# 查看容器的运行日志\n查看日志：docker logs[OPTIONS] 容器id或容器名 \n-t     加入时间戳\n-f     跟随最新的日志打印\n--tail 数字 显示最后多少条\n\n例：docker logs -t -f e6a\nctrl c 结束\n```\n\n### 进阶命令(容器内数据交互)\n\nlinux/windows --》 docker(引擎) --》mynginx(容器)\n\n```shell\nrequires at least xx arguments 至少需要的参数\n# 进入容器内部\n\ndocker exec 容器id \n-i 以交互模式运行容器，通常与 -t一起使用\n-t 分配一个伪终端 shell窗口 /bin/bash\ndocker exec -it  容器id /bin/bash\nls:列出目录文件\n\n# root权限进入\ndocker exec -u 0 -it 容器名 /bin/bash\n\n# 查看修改容器内软件配置\n查看主页：cat /usr/share/nginx/html/index.html\n\n更改主页内容：echo \"i love docker\" >  /usr/share/nginx/html/index.html\n\n也可以用vim修改\n# 容器内安装安装软件\n安装apt-get update\n\n终端：apt-get install vim      Ubuntu窗口，用来修改index\n\nvim /usr/share/nginx/html/index.html\n\n编辑好shift zz 保存退出\n\n# 容器内换源\nmv /etc/apt/sources.list /etc/apt/sources.list.bak\ncat <<EOF >/etc/apt/sources.list\ndeb http://mirrors.ustc.edu.cn/debian stable main contrib non-free\ndeb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free\nEOF\napt update\napt install vim\nmv /etc/apt/sources.list.bak /etc/apt/sources.list\n\n\n# 退出容器\nexit\n\n# 将容器打包为新的镜像\ndocker commit -a=\"作者\" -m=\"描述信息\" 容器ID 目标镜像名称：TAG\n\n# 拷贝\ndocker cp id:容器内资源路径 宿主机目录路径\n将容器资源拷贝到宿主机\n```\n\n\n\n### 交互步骤\n\n```shell\ndocker exec -it id /bin/bash\ncd /usr/share/nginx/html/\nls\npwd     查看当前位置\nexit\nls 检查当前已有文件\ndocker cp id:位置(/usr/share/nginx/html) .\nls\n\n```\n\npwd 是 Print Working Directory 的缩写，其功能是显示当前所在工作目录的全路径\n\n## docker的镜像原理\n\n>  镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。\n\n为什么一个镜像那么大\n\n**联合文件系统**，镜像被**分层**管理，体现是我们镜像多了之后，很多层不用重复下载\n\n\n\n', '<h2 id=\"docker\">Docker 命令</h2>\n<pre><code class=\"shell language-shell\"># 查看镜像|搜索|删除\n检查版本：docker --version             \n\n检查镜像是否生效:docker info                    \n\n查看镜像：docker images\n\n搜索镜像：docker search mysql:5.7.0 (5.7.0：搜索指定的版本)\n\n列出当前运行的容器：docker ps\n\n删除：docker rmi 容器id/mysql:版本号       \n\n强制删除：docker rmi 容器id -f   简写rm也可以\n\ndocker rmi -f $(docker images 镜像名 -q)\n\nctrl c 结束\n</code></pre>\n<h3 id=\"\">一般步骤</h3>\n<pre><code class=\"shell language-shell\">docker pull nginx\ndocker images\ndocker run -d -p 80:80 --name xx nginx  \ndocker ps\n{\ndocker ps -a 历史运行\ndocker rm 容器id 可删除历史中的容器\n}\ndocker ps\ndocker exec -it 容器id /bin/bash 进入容器进行交互\ncd /usr/share/nginx/html/\nls\n(xxxx index.html)\necho \"i love java\" &gt; index.html\ncat index.html       --i love java\ndocker commit 容器id lovenginx:1.11  上传自己修改的镜像\ndocker images\ndocker stop 容器id\ndocker ps\ndocker rm $(docker ps -qa)     删除所有运行\ndocker run -d -p 80:80 容器id   运行自己的镜像，须通过id\ndocker ps    \n</code></pre>\n<p><strong>ctrl insert复制</strong></p>\n<p><strong>shift insert 粘贴</strong></p>\n<hr />\n<h2 id=\"-1\">容器</h2>\n<p>一个镜像是一个应用环境</p>\n<h3 id=\"-2\">外部指令</h3>\n<pre><code class=\"shell language-shell\"># 运行容器\n\n启动应用：docker run  mysql\n\n-d 启动守护式容器(在后台启动容器，不占用窗口)\n--name 起别名\n-p 映射端口：原始端口号    指定端口号启动\n-P 随机分配端口\n\n例:不占用窗口并映射访问路径：docker run -d -p 80:80 mysql\n\n自定义名称：docker run -d -p 80:80 --name mynginx nginx\n# 查看运行容器\n查看运行容器：docker ps\n\n显示所有容器：docker ps -a\n-a 显示正在运行和历史运行\n-q 静默模式，只显示容器编号\n一起用：docker ps -qa \n\n# 停止|关闭\n开启容器：docker start 容器名字或者id\n重启容器：docker restart 容器名字或者id\n结束容器：docker stop 对应的id\n立即停止容器：docker kill id\n\n# 删除容器\n删除容器：docker rm id\n强制删除：docker rm id -f\n删除所有：docker rm -f $(docker ps -qa)\n\n# 删除镜像\ndocker ps -a 查看容器id\ndocker rmi 容器id ，先删除容器再删除镜像\ndocker rm -f 镜像id\n\n# 挂载文件目录\ndocker run -d -p 9090:9090 --name prometheus -v linux地址:容器内地址   bitnami/prometheus:latest \n如挂载多个使用 \\ 作为换行符 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n\n# 设置容器自启动\ndocker update redis --restart=always\n</code></pre>\n<h3 id=\"-3\">内部指令</h3>\n<pre><code class=\"shell language-shell\"># 查看容器内进程\n查看容器内的进程：docker top 容器id或容器name\n\n# 查看容器内部细节 \n查看内部细节：docker inspect 容器id\n\n# 查看容器的运行日志\n查看日志：docker logs[OPTIONS] 容器id或容器名 \n-t     加入时间戳\n-f     跟随最新的日志打印\n--tail 数字 显示最后多少条\n\n例：docker logs -t -f e6a\nctrl c 结束\n</code></pre>\n<h3 id=\"-4\">进阶命令(容器内数据交互)</h3>\n<p>linux/windows --》 docker(引擎) --》mynginx(容器)</p>\n<pre><code class=\"shell language-shell\">requires at least xx arguments 至少需要的参数\n# 进入容器内部\n\ndocker exec 容器id \n-i 以交互模式运行容器，通常与 -t一起使用\n-t 分配一个伪终端 shell窗口 /bin/bash\ndocker exec -it  容器id /bin/bash\nls:列出目录文件\n\n# root权限进入\ndocker exec -u 0 -it 容器名 /bin/bash\n\n# 查看修改容器内软件配置\n查看主页：cat /usr/share/nginx/html/index.html\n\n更改主页内容：echo \"i love docker\" &gt;  /usr/share/nginx/html/index.html\n\n也可以用vim修改\n# 容器内安装安装软件\n安装apt-get update\n\n终端：apt-get install vim      Ubuntu窗口，用来修改index\n\nvim /usr/share/nginx/html/index.html\n\n编辑好shift zz 保存退出\n\n# 容器内换源\nmv /etc/apt/sources.list /etc/apt/sources.list.bak\ncat &lt;&lt;EOF &gt;/etc/apt/sources.list\ndeb http://mirrors.ustc.edu.cn/debian stable main contrib non-free\ndeb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free\nEOF\napt update\napt install vim\nmv /etc/apt/sources.list.bak /etc/apt/sources.list\n\n\n# 退出容器\nexit\n\n# 将容器打包为新的镜像\ndocker commit -a=\"作者\" -m=\"描述信息\" 容器ID 目标镜像名称：TAG\n\n# 拷贝\ndocker cp id:容器内资源路径 宿主机目录路径\n将容器资源拷贝到宿主机\n</code></pre>\n<h3 id=\"-5\">交互步骤</h3>\n<pre><code class=\"shell language-shell\">docker exec -it id /bin/bash\ncd /usr/share/nginx/html/\nls\npwd     查看当前位置\nexit\nls 检查当前已有文件\ndocker cp id:位置(/usr/share/nginx/html) .\nls\n</code></pre>\n<p>pwd 是 Print Working Directory 的缩写，其功能是显示当前所在工作目录的全路径</p>\n<h2 id=\"docker-1\">docker的镜像原理</h2>\n<blockquote>\n  <p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>\n</blockquote>\n<p>为什么一个镜像那么大</p>\n<p><strong>联合文件系统</strong>，镜像被<strong>分层</strong>管理，体现是我们镜像多了之后，很多层不用重复下载</p>', '这里讲述了Docker的基本用法，容器的基本指令', 'http://8.129.122.160/group1/M00/00/00/CIF6oGRSKt6AQ3YwAACuuDVT7jk173.jpg', '2023-05-03 17:38:03', 1, 1, 1170, 0);
INSERT INTO `article` VALUES (36, ' 从零实现一个迷你数据库|如何通信', 4, 8, '本文章涉及的代码地址 https://github.com/thciwei/MiniDB\n\n数据库通信采用C/S结构，先上整体执行流程：\n\n![](https://gulimall-wqs.oss-cn-beijing.aliyuncs.com/typora/202302031703902.png)\n\n## C/S通信\n\n数据库通信类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果\n\n数据库通信采用一种自定义的二进制格式，当然这里采用明文通信也可以。\n\n我们通过`Package`类将数据封装为**数据包**，数据包的基本格式：\n\n```sh\n[Flag][data]\n若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；\n如果 flag 为 1，表示发送的是错误，data 是 err( Exception.getMessage()) 的错误提示信息。\n```\n\n具体类\n\n```java\npublic class Package {\n    byte[] data;\n    Exception err;\n```\n\n`Packager`类对外发送**数据包**，对内接收数据包，提供了send()、receive()方法，主要是调用`Encoder`和`Transporter`两个类的能力\n\n```java\npublic class Packager {\n    private Transporter transpoter;\n    private Encoder encoder;\n    \n    public Packager(Transporter transpoter, Encoder encoder)\n    public void send(Package pkg) throws Exception \n    public Package receive() throws Exception \n    public void close() throws Exception \n}\n```\n\n`Encoder`类负责对数据包编码和解码，而`Transporter`类用于对数据的**读写**，这里为了避免特殊字符造成问题，会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。\n\n```java\npublic class Transporter {\n    private Socket socket;\n    private BufferedReader reader;\n    private BufferedWriter writer;\n\n    public Transporter(Socket socket) throws IOException {\n        this.socket = socket;\n        this.reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n    }\n    //对数据16进制编码然后发送\n    public void send(byte[] data) throws Exception {\n        String raw = hexEncode(data);\n        writer.write(raw);\n        writer.flush();\n    }\n......................省略一部分\n    //16进制编码\n    private String hexEncode(byte[] buf) {\n        return Hex.encodeHexString(buf, true) + \"\\n\";\n    }\n    //16进制解码\n    private byte[] hexDecode(String buf) throws DecoderException {\n        return Hex.decodeHex(buf);\n    }\n}\n```\n\n## Server和Client\n\n客户端和服务端我们借助Java的socket即可。\n\n服务端提供了Server和Executor两个类。`Server类`作为服务端的启动类会启动一个ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理\n\n```java\npublic void start() {\n    ServerSocket ss = null;\n    try {\n        ss = new ServerSocket(port);\n    } catch (IOException e) {\n        e.printStackTrace();\n        return;\n    }\n    System.out.println(\"Server listen to port: \" + port);\n    //开启一个线程，当有请求到来时直接把请求丢给一个新线程处理\n    ThreadPoolExecutor tpe = new ThreadPoolExecutor(10, 20, 1L, TimeUnit.SECONDS, new ArrayBlockingQueue<>(100), new ThreadPoolExecutor.CallerRunsPolicy());\n    try {\n        while(true) {\n            Socket socket = ss.accept();\n            Runnable worker = new HandleSocket(socket, tbm);\n            //启动这个线程\n            tpe.execute(worker);\n        }\n    } catch(IOException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            ss.close();\n        } catch (IOException ignored) {}\n    }\n}\n```\n\nHandleSocket实现了runnable run方法，多线程循环不断接收客户端数据\n\n```java\n        Packager packager = null;\n        try {\n            Transporter t = new Transporter(socket);\n            Encoder e = new Encoder();\n            packager = new Packager(t, e);\n        } catch(IOException e) {\n            e.printStackTrace();\n            try {\n                socket.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            return;\n        }\n        Executor exe = new Executor(tbm);\n        //循环接收来自客户端的信息\n        while(true) {\n            Package pkg = null;\n            try {\n                pkg = packager.receive();\n            } catch(Exception e) {\n                break;\n            }\n            byte[] sql = pkg.getData();\n            byte[] result = null;\n            Exception e = null;\n            try {\n                result = exe.execute(sql);\n            } catch (Exception e1) {\n                e = e1;\n                e.printStackTrace();\n            }\n            pkg = new Package(result, e);\n            try {\n                packager.send(pkg);\n            } catch (Exception e1) {\n                e1.printStackTrace();\n                break;\n            }\n        }\n        exe.close();\n        try {\n            packager.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    \n}\n```\n\n启动Client端接收用户输入的shell内容，Server类调用Executor的execute执行方法。`Executor`是处理的核心，通过调用`Parser`解析sql语句，根据语句的不同类型交给字段与表管理器去做进一步处理，在vm层开启事务、初始化事务结构......。\n\n```java\npublic byte[] execute(byte[] sql) throws Exception {\n    System.out.println(\"Execute: \" + new String(sql));\n    Object stat = Parser.Parse(sql);\n    if (Begin.class.isInstance(stat)) {\n        if (xid != 0) {\n            throw Error.NestedTransactionException;\n        }\n        BeginRes r = tbm.begin((Begin) stat);\n        xid = r.xid;\n        return r.result;\n    } else if (Commit.class.isInstance(stat)) {\n        if (xid == 0) {\n            throw Error.NoTransactionException;\n        }\n        byte[] res = tbm.commit(xid);\n        xid = 0;\n        return res;\n    } else if (Abort.class.isInstance(stat)) {\n        if (xid == 0) {\n            throw Error.NoTransactionException;\n        }\n        byte[] res = tbm.abort(xid);\n        xid = 0;\n        return res;\n    } else {\n        //不是begin commit  abort，可能是insert update等的情况调用该方法\n        return execute2(stat);\n    }\n}\n```\n\nbackend包下面的Launcher是`服务端的入口`，这个类解析了命令行参数。很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。open和create对应着两个方法如下：\n\n```java\nprivate static void createDB(String path) {\n    TransactionManager tm = TransactionManager.create(path);\n    DataManager dm = DataManager.create(path, DEFALUT_MEM, tm);\n    VersionManager vm = new VersionManagerImpl(tm, dm);\n    TableManager.create(path, vm, dm);\n    tm.close();\n    dm.close();\n}\nprivate static void openDB(String path, long mem) {\n    TransactionManager tm = TransactionManager.open(path);\n    DataManager dm = DataManager.open(path, mem, tm);\n    VersionManager vm = new VersionManagerImpl(tm, dm);\n    TableManager tbm = TableManager.open(path, vm, dm);\n    new Server(port, tbm).start();\n}\n```\n\nclient包下面的Launcher是`客户端的入口`，如下：\n\n```java\npublic class Launcher {\n    public static void main(String[] args) throws UnknownHostException, IOException {\n        Socket socket = new Socket(\"127.0.0.1\", 9999);\n        Encoder e = new Encoder();\n        Transporter t = new Transporter(socket);\n        Packager packager = new Packager(t, e);\n\n        Client client = new Client(packager);\n        Shell shell = new Shell(client);\n        shell.run();\n    }\n}\n```\n', '<p>本文章涉及的代码地址 https://github.com/thciwei/MiniDB</p>\n<p>数据库通信采用C/S结构，先上整体执行流程：</p>\n<p><img src=\"https://gulimall-wqs.oss-cn-beijing.aliyuncs.com/typora/202302031703902.png\" alt=\"\" /></p>\n<h2 id=\"cs\">C/S通信</h2>\n<p>数据库通信类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果</p>\n<p>数据库通信采用一种自定义的二进制格式，当然这里采用明文通信也可以。</p>\n<p>我们通过<code>Package</code>类将数据封装为<strong>数据包</strong>，数据包的基本格式：</p>\n<pre><code class=\"sh language-sh\">[Flag][data]\n若 flag 为 0，表示发送的是数据，那么 data 即为这份数据本身；\n如果 flag 为 1，表示发送的是错误，data 是 err( Exception.getMessage()) 的错误提示信息。\n</code></pre>\n<p>具体类</p>\n<pre><code class=\"java language-java\">public class Package {\n    byte[] data;\n    Exception err;\n</code></pre>\n<p><code>Packager</code>类对外发送<strong>数据包</strong>，对内接收数据包，提供了send()、receive()方法，主要是调用<code>Encoder</code>和<code>Transporter</code>两个类的能力</p>\n<pre><code class=\"java language-java\">public class Packager {\n    private Transporter transpoter;\n    private Encoder encoder;\n\n    public Packager(Transporter transpoter, Encoder encoder)\n    public void send(Package pkg) throws Exception \n    public Package receive() throws Exception \n    public void close() throws Exception \n}\n</code></pre>\n<p><code>Encoder</code>类负责对数据包编码和解码，而<code>Transporter</code>类用于对数据的<strong>读写</strong>，这里为了避免特殊字符造成问题，会将数据转成十六进制字符串（Hex String），并为信息末尾加上换行符。</p>\n<pre><code class=\"java language-java\">public class Transporter {\n    private Socket socket;\n    private BufferedReader reader;\n    private BufferedWriter writer;\n\n    public Transporter(Socket socket) throws IOException {\n        this.socket = socket;\n        this.reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        this.writer = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));\n    }\n    //对数据16进制编码然后发送\n    public void send(byte[] data) throws Exception {\n        String raw = hexEncode(data);\n        writer.write(raw);\n        writer.flush();\n    }\n......................省略一部分\n    //16进制编码\n    private String hexEncode(byte[] buf) {\n        return Hex.encodeHexString(buf, true) + \"\\n\";\n    }\n    //16进制解码\n    private byte[] hexDecode(String buf) throws DecoderException {\n        return Hex.decodeHex(buf);\n    }\n}\n</code></pre>\n<h2 id=\"serverclient\">Server和Client</h2>\n<p>客户端和服务端我们借助Java的socket即可。</p>\n<p>服务端提供了Server和Executor两个类。<code>Server类</code>作为服务端的启动类会启动一个ServerSocket 监听端口，当有请求到来时直接把请求丢给一个新线程处理</p>\n<pre><code class=\"java language-java\">public void start() {\n    ServerSocket ss = null;\n    try {\n        ss = new ServerSocket(port);\n    } catch (IOException e) {\n        e.printStackTrace();\n        return;\n    }\n    System.out.println(\"Server listen to port: \" + port);\n    //开启一个线程，当有请求到来时直接把请求丢给一个新线程处理\n    ThreadPoolExecutor tpe = new ThreadPoolExecutor(10, 20, 1L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(100), new ThreadPoolExecutor.CallerRunsPolicy());\n    try {\n        while(true) {\n            Socket socket = ss.accept();\n            Runnable worker = new HandleSocket(socket, tbm);\n            //启动这个线程\n            tpe.execute(worker);\n        }\n    } catch(IOException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            ss.close();\n        } catch (IOException ignored) {}\n    }\n}\n</code></pre>\n<p>HandleSocket实现了runnable run方法，多线程循环不断接收客户端数据</p>\n<pre><code class=\"java language-java\">        Packager packager = null;\n        try {\n            Transporter t = new Transporter(socket);\n            Encoder e = new Encoder();\n            packager = new Packager(t, e);\n        } catch(IOException e) {\n            e.printStackTrace();\n            try {\n                socket.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n            return;\n        }\n        Executor exe = new Executor(tbm);\n        //循环接收来自客户端的信息\n        while(true) {\n            Package pkg = null;\n            try {\n                pkg = packager.receive();\n            } catch(Exception e) {\n                break;\n            }\n            byte[] sql = pkg.getData();\n            byte[] result = null;\n            Exception e = null;\n            try {\n                result = exe.execute(sql);\n            } catch (Exception e1) {\n                e = e1;\n                e.printStackTrace();\n            }\n            pkg = new Package(result, e);\n            try {\n                packager.send(pkg);\n            } catch (Exception e1) {\n                e1.printStackTrace();\n                break;\n            }\n        }\n        exe.close();\n        try {\n            packager.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n</code></pre>\n<p>启动Client端接收用户输入的shell内容，Server类调用Executor的execute执行方法。<code>Executor</code>是处理的核心，通过调用<code>Parser</code>解析sql语句，根据语句的不同类型交给字段与表管理器去做进一步处理，在vm层开启事务、初始化事务结构……。</p>\n<pre><code class=\"java language-java\">public byte[] execute(byte[] sql) throws Exception {\n    System.out.println(\"Execute: \" + new String(sql));\n    Object stat = Parser.Parse(sql);\n    if (Begin.class.isInstance(stat)) {\n        if (xid != 0) {\n            throw Error.NestedTransactionException;\n        }\n        BeginRes r = tbm.begin((Begin) stat);\n        xid = r.xid;\n        return r.result;\n    } else if (Commit.class.isInstance(stat)) {\n        if (xid == 0) {\n            throw Error.NoTransactionException;\n        }\n        byte[] res = tbm.commit(xid);\n        xid = 0;\n        return res;\n    } else if (Abort.class.isInstance(stat)) {\n        if (xid == 0) {\n            throw Error.NoTransactionException;\n        }\n        byte[] res = tbm.abort(xid);\n        xid = 0;\n        return res;\n    } else {\n        //不是begin commit  abort，可能是insert update等的情况调用该方法\n        return execute2(stat);\n    }\n}\n</code></pre>\n<p>backend包下面的Launcher是<code>服务端的入口</code>，这个类解析了命令行参数。很重要的参数就是 -open 或者 -create。Launcher 根据两个参数，来决定是创建数据库文件，还是启动一个已有的数据库。open和create对应着两个方法如下：</p>\n<pre><code class=\"java language-java\">private static void createDB(String path) {\n    TransactionManager tm = TransactionManager.create(path);\n    DataManager dm = DataManager.create(path, DEFALUT_MEM, tm);\n    VersionManager vm = new VersionManagerImpl(tm, dm);\n    TableManager.create(path, vm, dm);\n    tm.close();\n    dm.close();\n}\nprivate static void openDB(String path, long mem) {\n    TransactionManager tm = TransactionManager.open(path);\n    DataManager dm = DataManager.open(path, mem, tm);\n    VersionManager vm = new VersionManagerImpl(tm, dm);\n    TableManager tbm = TableManager.open(path, vm, dm);\n    new Server(port, tbm).start();\n}\n</code></pre>\n<p>client包下面的Launcher是<code>客户端的入口</code>，如下：</p>\n<pre><code class=\"java language-java\">public class Launcher {\n    public static void main(String[] args) throws UnknownHostException, IOException {\n        Socket socket = new Socket(\"127.0.0.1\", 9999);\n        Encoder e = new Encoder();\n        Transporter t = new Transporter(socket);\n        Packager packager = new Packager(t, e);\n\n        Client client = new Client(packager);\n        Shell shell = new Shell(client);\n        shell.run();\n    }\n}\n</code></pre>', '数据库通信采用C/S结构，先上整体执行流程', 'http://gulimall-wqs.oss-cn-beijing.aliyuncs.com/typora/202302031703902.png', '2023-05-03 17:40:19', 1, 1, 1137, 0);
INSERT INTO `article` VALUES (37, 'Spring学习笔记', 3, 2, '### Spring 框架两大核心机制（IoC、AOP）\n\n- IoC（控制反转）/ DI（依赖注入）\n- AOP（面向切面编程）\n\nSpring 是一个企业级开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。\n\nMVC：Struts2、Spring MVC\n\nORMapping：Hibernate、MyBatis、Spring Data\n\n### 如何使用 IoC\n\n* 什么是控制反转\n\n在传统的程序开发中，需要调用对象时，通常由调用者来创建被调用者的实例，即对象是由调用者主动new出来的。\n\n 但在 Spring A框架中创建对象的工作不再由调用者来完成，而是交给IoC容器来创建，再推送给调用者整个流程完成反转，所以是控制反转。\n\n- 创建 Maven 工程，pom.xml 添加依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.southwind</groupId>\n    <artifactId>aispringioc</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.0.11.RELEASE</version>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n- 创建实体类 Student\n\n```java\npackage com.thciwei.entity;\n\nimport lombok.Data;\n\n@Data\npublic class Student {\n    private long id;\n    private String name;\n    private int age;\n}\n```\n\n- 传统的开发方式，手动 new Student\n\n```java\nStudent student = new Student();\nstudent.setId(1L);\nstudent.setName(\"张三\");\nstudent.setAge(22);\nSystem.out.println(student);\n```\n\n- 通过 IoC 创建对象，在配置文件中添加需要管理的对象，XML 格式的配置文件，文件名可以自定义。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\">\n\n    <bean id=\"student\" class=\"com.southwind.entity.Student\">\n        <property name=\"id\" value=\"1\"></property>\n        <property name=\"name\" value=\"张三\"></property>\n        <property name=\"age\" value=\"22\"></property>\n    </bean>\n\n</beans>\n```\n\n- 从 IoC 中获取对象，通过 id 获取。\n\n```java\n//加载配置文件\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\");\nStudent student = (Student) applicationContext.getBean(\"student\");\nSystem.out.println(student);\n```\n\n\n\n### 配置文件\n\n- 通过配置 `bean` 标签来完成对象的管理。\n\n  - `id`：对象名。\n\n  - `class`：对象的模版类（所有交给 IoC 容器来管理的类必须有无参构造函数，因为 Spring 底层是通过反射机制来创建对象，调用的是无参构造）\n\n- 对象的成员变量通过 `property` 标签完成赋值。\n\n  - `name`：成员变量名。\n  - `value`：成员变量值（基本数据类型，String 可以直接赋值，如果是其他引用类型，不能通过 value 赋值）\n  - `ref`：将 IoC 中的另外一个 bean 赋给当前的成员变量（DI）\n\n  ```xml\n  <bean id=\"student\" class=\"com.southwind.entity.Student\">\n      <property name=\"id\" value=\"1\"></property>\n      <property name=\"name\" value=\"张三\"></property>\n      <property name=\"age\" value=\"22\"></property>\n      <property name=\"address\" ref=\"address\"></property>\n  </bean>\n  \n  <bean id=\"address\" class=\"com.southwind.entity.Address\">\n      <property name=\"id\" value=\"1\"></property>\n      <property name=\"name\" value=\"科技路\"></property>\n  </bean>\n  ```\n\n  \n\n### IoC 底层原理\n\n- 读取配置文件，解析 XML。\n- 通过反射机制实例化配置文件中所配置所有的 bean。\n\n为什么一定要有无参构造，IoC 容器通过无参构造帮你创建对象\n\n```java\npackage com.thciwei.ioc;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n    private Map<String,Object> ioc = new HashMap<String, Object>();\n    public ClassPathXmlApplicationContext(String path){\n        try {\n            SAXReader reader = new SAXReader();\n            Document document = reader.read(\"./src/main/resources/\"+path);\n            Element root = document.getRootElement();\n            Iterator<Element> iterator = root.elementIterator();\n            while(iterator.hasNext()){\n                Element element = iterator.next();\n                String id = element.attributeValue(\"id\");\n                String className = element.attributeValue(\"class\");\n                //通过反射机制创建对象\n                Class clazz = Class.forName(className);\n                //获取无参构造函数，创建目标对象\n                Constructor constructor = clazz.getConstructor();\n                Object object = constructor.newInstance();\n                //给目标对象赋值\n                Iterator<Element> beanIter = element.elementIterator();\n                while(beanIter.hasNext()){\n                    Element property = beanIter.next();\n                    String name = property.attributeValue(\"name\");\n                    String valueStr = property.attributeValue(\"value\");\n                    String ref = property.attributeValue(\"ref\");\n                    if(ref == null){\n                        String methodName = \"set\"+name.substring(0,1).toUpperCase()+name.substring(1);\n                        Field field = clazz.getDeclaredField(name);\n                        Method method = clazz.getDeclaredMethod(methodName,field.getType());\n                        //根据成员变量的数据类型将 value 进行转换\n                        Object value = null;\n                        if(field.getType().getName() == \"long\"){\n                            value = Long.parseLong(valueStr);\n                        }\n                        if(field.getType().getName() == \"java.lang.String\"){\n                            value = valueStr;\n                        }\n                        if(field.getType().getName() == \"int\"){\n                            value = Integer.parseInt(valueStr);\n                        }\n                        method.invoke(object,value);\n                    }\n                    ioc.put(id,object);\n                }\n            }\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e){\n            e.printStackTrace();\n        } catch (NoSuchMethodException e){\n            e.printStackTrace();\n        } catch (InstantiationException e){\n            e.printStackTrace();\n        } catch (IllegalAccessException e){\n            e.printStackTrace();\n        } catch (InvocationTargetException e){\n            e.printStackTrace();\n        } catch (NoSuchFieldException e){\n            e.printStackTrace();\n        }\n    }\n\n    public Object getBean(String id) {\n        return ioc.get(id);\n    }\n}\n```\n\n\n\n### 通过运行时类获取 bean\n\n```java\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\");\nStudent student = (Student) applicationContext.getBean(Student.class);\nSystem.out.println(student);\n```\n\n这种方式存在一个问题，配置文件中一个数据类型的对象只能有一个实例，否则会抛出异常，因为没有唯一的 bean。\n\n\n\n### 通过有参构造创建 bean\n\n- 在实体类中创建对应的有参构造函数。\n- 配置文件\n\n```xml\n<bean id=\"student3\" class=\"com.southwind.entity.Student\">\n    <constructor-arg name=\"id\" value=\"3\"></constructor-arg>\n    <constructor-arg name=\"name\" value=\"小明\"></constructor-arg>\n    <constructor-arg name=\"age\" value=\"18\"></constructor-arg>\n    <constructor-arg name=\"address\" ref=\"address\"></constructor-arg>\n</bean>\n```\n\n\n\n```xml\n<bean id=\"student3\" class=\"com.southwind.entity.Student\">\n    <constructor-arg index=\"0\" value=\"3\"></constructor-arg>\n    <constructor-arg index=\"2\" value=\"18\"></constructor-arg>\n    <constructor-arg index=\"1\" value=\"小明\"></constructor-arg>\n    <constructor-arg index=\"3\" ref=\"address\"></constructor-arg>\n</bean>\n```\n\n\n\n### 给 bean 注入集合\n\n```xml\n<bean id=\"student\" class=\"com.southwind.entity.Student\">\n    <property name=\"id\" value=\"2\"></property>\n    <property name=\"name\" value=\"李四\"></property>\n    <property name=\"age\" value=\"33\"></property>\n    <property name=\"addresses\">\n        <list>\n            <ref bean=\"address\"></ref>\n            <ref bean=\"address2\"></ref>\n        </list>\n    </property>\n</bean>\n\n<bean id=\"address\" class=\"com.southwind.entity.Address\">\n    <property name=\"id\" value=\"1\"></property>\n    <property name=\"name\" value=\"科技路\"></property>\n</bean>\n\n<bean id=\"address2\" class=\"com.southwind.entity.Address\">\n    <property name=\"id\" value=\"2\"></property>\n    <property name=\"name\" value=\"高新区\"></property>\n</bean>\n```\n\n\n\n### scope 作用域\n\n默认是单例模式，及创造的对象来自同一块地址，改为prototype，则输出false\n\n```java\nStudent student = (Student) applicationContext.getBean(Student.class);\nStudent student1 = (Student) applicationContext.getBean(Student.class);\nsout(student==student1)  //true\n\n```\n\nSpring 管理的 bean 是根据 scope 来生成的，表示 bean 的作用域，共4种，默认值是 singleton。\n\n- singleton：单例，表示通过 IoC 容器获取的 bean 是唯一的。\n- prototype：原型，表示通过 IoC 容器获取的 bean 是不同的。\n- request：请求，表示在一次 HTTP 请求内有效。\n- session：回话，表示在一个用户会话内有效。\n\nrequest 和 session 只适用于 Web 项目，大多数情况下，使用单例和原型较多。\n\nprototype 模式当业务代码获取 IoC 容器中的 bean 时，Spring 才去调用无参构造创建对应的 bean。\n\nsingleton 模式无论业务代码是否获取 IoC 容器中的 bean，Spring 在加载 spring.xml 时就会创建 bean。\n\n\n\n### Spring 的继承\n\n与 Java 的继承不同，Java 是类层面的继承，子类可以继承父类的内部结构信息；Spring 是对象层面的继承，子对象可以继承父对象的属性值。\n\n```xml\n<bean id=\"student2\" class=\"com.southwind.entity.Student\">\n    <property name=\"id\" value=\"1\"></property>\n    <property name=\"name\" value=\"张三\"></property>\n    <property name=\"age\" value=\"22\"></property>\n    <property name=\"addresses\">\n        <list>\n            <ref bean=\"address\"></ref>\n            <ref bean=\"address2\"></ref>\n        </list>\n    </property>\n</bean>\n\n<bean id=\"address\" class=\"com.southwind.entity.Address\">\n    <property name=\"id\" value=\"1\"></property>\n    <property name=\"name\" value=\"科技路\"></property>\n</bean>\n\n<bean id=\"address2\" class=\"com.southwind.entity.Address\">\n    <property name=\"id\" value=\"2\"></property>\n    <property name=\"name\" value=\"高新区\"></property>\n</bean>\n\n<bean id=\"stu\" class=\"com.southwind.entity.Student\" parent=\"student2\">\n    <property name=\"name\" value=\"李四\"></property>\n</bean>\n```\n\nSpring 的继承关注点在于具体的对象，而不在于类，即不同的两个类的实例化对象可以完成继承，前提是子对象必须包含父对象的所有属性，同时可以在此基础上添加其他的属性。\n\n\n\n### Spring 的依赖\n\n与继承类似，依赖也是描述 bean 和 bean 之间的一种关系，配置依赖之后，被依赖的 bean 一定先创建，再创建依赖的 bean，A 依赖于 B，先创建 B，再创建 A。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n                           \">\n\n    <bean id=\"student\" class=\"com.southwind.entity.Student\" depends-on=\"user\"></bean>\n\n    <bean id=\"user\" class=\"com.southwind.entity.User\"></bean>\n\n</beans>\n```\n\n\n\n### Spring 的 p 命名空间\n\np 命名空间是对 IoC / DI 的简化操作，使用 p 命名空间可以更加方便的完成 bean 的配置以及 bean 之间的依赖注入。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\">\n\n    <bean id=\"student\" class=\"com.southwind.entity.Student\" p:id=\"1\" p:name=\"张三\" p:age=\"22\" p:address-ref=\"address\"></bean>\n\n    <bean id=\"address\" class=\"com.southwind.entity.Address\" p:id=\"2\" p:name=\"科技路\"></bean>\n\n</beans>\n```\n\n\n\n### Spring 的工厂方法\n\n为什么会有外部bean注入，因为有的实例可能没办法new，可能new方法完全私有，但又想注册到ioc容器\n\nIoC 通过工厂模式创建 bean 的方式有两种：\n\n- 静态工厂方法\n- 实例工厂方法\n\n> 静态工厂方法\n\n```java\npackage com.southwind.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Car {\n    private long id;\n    private String name;\n}\n```\n\n```java\npackage com.thciwei.factory;\n\nimport com.southwind.entity.Car;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class StaticCarFactory {\n    private static Map<Long, Car> carMap;\n    static{\n        carMap = new HashMap<Long, Car>();\n        carMap.put(1L,new Car(1L,\"宝马\"));\n        carMap.put(2L,new Car(2L,\"奔驰\"));\n    }\n\n    public static Car getCar(long id){\n        return carMap.get(id);\n    }\n}\n```\n\n```xml\n<!-- 配置静态工厂创建 Car -->\n<bean id=\"car\" class=\"com.southwind.factory.StaticCarFactory\" factory-method=\"getCar\">\n    <constructor-arg value=\"2\"></constructor-arg>\n</bean>\n```\n\n> 实例工厂方法\n\n```java\npackage com.thciwei.factory;\n\nimport com.southwind.entity.Car;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class InstanceCarFactory {\n    private Map<Long, Car> carMap;\n    public InstanceCarFactory(){\n        carMap = new HashMap<Long, Car>();\n        carMap.put(1L,new Car(1L,\"宝马\"));\n        carMap.put(2L,new Car(2L,\"奔驰\"));\n    }\n\n    public Car getCar(long id){\n        return carMap.get(id);\n    }\n}\n```\n\n```xml\n<!-- 配置实例工厂 bean -->\n<bean id=\"carFactory\" class=\"com.southwind.factory.InstanceCarFactory\"></bean>\n\n<!-- 赔偿实例工厂创建 Car -->\n<bean id=\"car2\" factory-bean=\"carFactory\" factory-method=\"getCar\">\n    <constructor-arg value=\"1\"></constructor-arg>\n</bean>\n```\n\n\n\n### IoC 自动装载（Autowire）\n\nIoC 负责创建对象，DI 负责完成对象的依赖注入，通过配置 property 标签的 ref 属性来完成，同时 Spring 提供了另外一种更加简便的依赖注入方式：自动装载，不需要手动配置 property，IoC 容器会自动选择 bean 完成注入。\n\n自动装载有两种方式：\n\n- byName：通过属性名自动装载\n- byType：通过属性的数据类型自动装载\n\n> byName\n\n```xml\n<bean id=\"cars\" class=\"com.southwind.entity.Car\">\n    <property name=\"id\" value=\"1\"></property>\n    <property name=\"name\" value=\"宝马\"></property>\n</bean>\n\n<bean id=\"person\" class=\"com.southwind.entity.Person\" autowire=\"byName\">\n    <property name=\"id\" value=\"11\"></property>\n    <property name=\"name\" value=\"张三\"></property>\n</bean>\n```\n\n> byType\n\n```xml\n<bean id=\"car\" class=\"com.southwind.entity.Car\">\n    <property name=\"id\" value=\"2\"></property>\n    <property name=\"name\" value=\"奔驰\"></property>\n</bean>\n\n<bean id=\"person\" class=\"com.southwind.entity.Person\" autowire=\"byType\">\n    <property name=\"id\" value=\"11\"></property>\n    <property name=\"name\" value=\"张三\"></property>\n</bean>\n```\n\nbyType 需要注意，如果同时存在两个及以上的符合条件的 bean 时，自动装载会抛出异常。\n\n### 注解\n\nservice其实是为了批量注册bean\n\n\n\n### AOP\n\nAOP：Aspect Oriented Programming 面向切面编程。\n\nAOP 的优点：\n\n- 降低模块之间的耦合度。\n- 使系统更容易扩展。\n- 更好的代码复用。\n- 非业务代码更加集中，不分散，便于统一管理。\n- 业务代码更加简洁存粹，不参杂其他代码的影响。\n\nAOP 是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面对象，对该切面对象进行编程就是 AOP。\n\n### 如何使用？\n\n- 创建 Maven 工程，pom.xml 添加\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.0.11.RELEASE</version>\n    </dependency>\n    \n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-aop</artifactId>\n        <version>5.0.11.RELEASE</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-aspects</artifactId>\n        <version>5.0.11.RELEASE</version>\n    </dependency>\n</dependencies>\n```\n\n- 创建一个计算器接口 Cal，定义4个方法。\n\n```java\npackage com.thciwei.utils;\n\npublic interface Cal {\n    public int add(int num1,int num2);\n    public int sub(int num1,int num2);\n    public int mul(int num1,int num2);\n    public int div(int num1,int num2);\n}\n```\n\n- 创建接口的实现类 CalImpl。\n\n```java\npackage com.thciwei.utils.impl;\n\nimport com.southwind.utils.Cal;\n\npublic class CalImpl implements Cal {\n    public int add(int num1, int num2) {\n        System.out.println(\"add方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1+num2;\n        System.out.println(\"add方法的结果是\"+result);\n        return result;\n    }\n\n    public int sub(int num1, int num2) {\n        System.out.println(\"sub方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1-num2;\n        System.out.println(\"sub方法的结果是\"+result);\n        return result;\n    }\n\n    public int mul(int num1, int num2) {\n        System.out.println(\"mul方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1*num2;\n        System.out.println(\"mul方法的结果是\"+result);\n        return result;\n    }\n\n    public int div(int num1, int num2) {\n        System.out.println(\"div方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1/num2;\n        System.out.println(\"div方法的结果是\"+result);\n        return result;\n    }\n}\n```\n\n\n\n上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用 AOP 可以进行优化，如何来实现 AOP？使用动态代理的方式来实现。\n\n给业务代码找一个代理，打印日志信息的工作交个代理来做，这样的话业务代码就只需要关注自身的业务即可。\n\n```java\npackage com.thciwei.utils;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\n\npublic class MyInvocationHandler implements InvocationHandler {\n    //接收委托对象\n    private Object object = null;\n\n    //返回代理对象\n    public Object bind(Object object){\n        this.object = object;\n        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(method.getName()+\"方法的参数是：\"+ Arrays.toString(args));\n        Object result = method.invoke(this.object,args);\n        System.out.println(method.getName()+\"的结果是\"+result);\n        return result;\n    }\n}\n```\n\n以上是通过动态代理实现 AOP 的过程，比较复杂，不好理解，Spring 框架对 AOP 进行了封装，使用 Spring 框架可以用面向对象的思想来实现 AOP。\n\nSpring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成即可，Spring 框架底层会自动根据切面类以及目标类生成一个代理对象。\n\nLoggerAspect\n\n```java\npackage com.thciwei.aop;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Arrays;\n\n@Aspect\n@Component\npublic class LoggerAspect {\n\n    @Before(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\")\n    public void before(JoinPoint joinPoint){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        //获取参数\n        String args = Arrays.toString(joinPoint.getArgs());\n        System.out.println(name+\"方法的参数是：\"+ args);\n    }\n\n    @After(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\")\n    public void after(JoinPoint joinPoint){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        System.out.println(name+\"方法执行完毕\");\n    }\n\n    @AfterReturning(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\",returning = \"result\")\n    public void afterReturning(JoinPoint joinPoint,Object result){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        System.out.println(name+\"方法的结果是\"+result);\n    }\n\n    @AfterThrowing(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\",throwing = \"exception\")\n    public void afterThrowing(JoinPoint joinPoint,Exception exception){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        System.out.println(name+\"方法抛出异常：\"+exception);\n    }\n\n}\n```\n\nLoggerAspect 类定义处添加的两个注解：\n\n- `@Aspect`：表示该类是切面类。\n- `@Component`：将该类的对象注入到 IoC 容器。\n\n具体方法处添加的注解：\n\n`@Before`：表示方法执行的具体位置和时机。\n\nCalImpl 也需要添加 `@Component`，交给 IoC 容器来管理。\n\n```java\npackage com.thciwei.utils.impl;\n\nimport com.southwind.utils.Cal;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CalImpl implements Cal {\n    public int add(int num1, int num2) {\n        int result = num1+num2;\n        return result;\n    }\n\n    public int sub(int num1, int num2) {\n        int result = num1-num2;\n        return result;\n    }\n\n    public int mul(int num1, int num2) {\n        int result = num1*num2;\n        return result;\n    }\n\n    public int div(int num1, int num2) {\n        int result = num1/num2;\n        return result;\n    }\n}\n```\n\nxxxxxxxxxx create index idx_email using hash on student(email)sql\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\">\n\n    <!-- 自动扫描 -->\n    <context:component-scan base-package=\"com.southwind\"></context:component-scan>\n\n    <!-- 是Aspect注解生效，为目标类自动生成代理对象 -->\n    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\n</beans>\n```\n\n`context:component-scan` 将 `com.southwind` 包中的所有类进行扫描，如果该类同时添加了 `@Component`，则将该类扫描到 IoC 容器中，即 IoC 管理它的对象。\n\n`aop:aspectj-autoproxy` 让 Spring 框架结合切面类和目标类自动生成动态代理对象。\n\n- 切面：横切关注点被模块化的抽象对象。\n- 通知：切面对象完成的工作。\n- 目标：被通知的对象，即被横切的对象。\n- 代理：切面、通知、目标混合之后的对象。\n- 连接点：通知要插入业务代码的具体位置。\n- 切点：AOP 通过切点定位到连接点。', '<h3 id=\"springiocaop\">Spring 框架两大核心机制（IoC、AOP）</h3>\n<ul>\n<li>IoC（控制反转）/ DI（依赖注入）</li>\n<li>AOP（面向切面编程）</li>\n</ul>\n<p>Spring 是一个企业级开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。</p>\n<p>MVC：Struts2、Spring MVC</p>\n<p>ORMapping：Hibernate、MyBatis、Spring Data</p>\n<h3 id=\"ioc\">如何使用 IoC</h3>\n<ul>\n<li>什么是控制反转</li>\n</ul>\n<p>在传统的程序开发中，需要调用对象时，通常由调用者来创建被调用者的实例，即对象是由调用者主动new出来的。</p>\n<p>但在 Spring A框架中创建对象的工作不再由调用者来完成，而是交给IoC容器来创建，再推送给调用者整个流程完成反转，所以是控制反转。</p>\n<ul>\n<li>创建 Maven 工程，pom.xml 添加依赖</li>\n</ul>\n<pre><code class=\"xml language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.southwind&lt;/groupId&gt;\n    &lt;artifactId&gt;aispringioc&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n            &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n&lt;/project&gt;\n</code></pre>\n<ul>\n<li>创建实体类 Student</li>\n</ul>\n<pre><code class=\"java language-java\">package com.thciwei.entity;\n\nimport lombok.Data;\n\n@Data\npublic class Student {\n    private long id;\n    private String name;\n    private int age;\n}\n</code></pre>\n<ul>\n<li>传统的开发方式，手动 new Student</li>\n</ul>\n<pre><code class=\"java language-java\">Student student = new Student();\nstudent.setId(1L);\nstudent.setName(\"张三\");\nstudent.setAge(22);\nSystem.out.println(student);\n</code></pre>\n<ul>\n<li>通过 IoC 创建对象，在配置文件中添加需要管理的对象，XML 格式的配置文件，文件名可以自定义。</li>\n</ul>\n<pre><code class=\"xml language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\"&gt;\n\n    &lt;bean id=\"student\" class=\"com.southwind.entity.Student\"&gt;\n        &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt;\n        &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n        &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<ul>\n<li>从 IoC 中获取对象，通过 id 获取。</li>\n</ul>\n<pre><code class=\"java language-java\">//加载配置文件\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\");\nStudent student = (Student) applicationContext.getBean(\"student\");\nSystem.out.println(student);\n</code></pre>\n<h3 id=\"\">配置文件</h3>\n<ul>\n<li><p>通过配置 <code>bean</code> 标签来完成对象的管理。</p></li>\n<li><p><code>id</code>：对象名。</p></li>\n<li><p><code>class</code>：对象的模版类（所有交给 IoC 容器来管理的类必须有无参构造函数，因为 Spring 底层是通过反射机制来创建对象，调用的是无参构造）</p></li>\n<li><p>对象的成员变量通过 <code>property</code> 标签完成赋值。</p></li>\n<li><p><code>name</code>：成员变量名。</p></li>\n<li><p><code>value</code>：成员变量值（基本数据类型，String 可以直接赋值，如果是其他引用类型，不能通过 value 赋值）</p></li>\n<li><p><code>ref</code>：将 IoC 中的另外一个 bean 赋给当前的成员变量（DI）</p></li>\n</ul>\n<pre><code class=\"xml language-xml\">  &lt;bean id=\"student\" class=\"com.southwind.entity.Student\"&gt;\n      &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt;\n      &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n      &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;\n      &lt;property name=\"address\" ref=\"address\"&gt;&lt;/property&gt;\n  &lt;/bean&gt;\n\n  &lt;bean id=\"address\" class=\"com.southwind.entity.Address\"&gt;\n      &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt;\n      &lt;property name=\"name\" value=\"科技路\"&gt;&lt;/property&gt;\n  &lt;/bean&gt;\n</code></pre>\n<h3 id=\"ioc-1\">IoC 底层原理</h3>\n<ul>\n<li>读取配置文件，解析 XML。</li>\n<li>通过反射机制实例化配置文件中所配置所有的 bean。</li>\n</ul>\n<p>为什么一定要有无参构造，IoC 容器通过无参构造帮你创建对象</p>\n<pre><code class=\"java language-java\">package com.thciwei.ioc;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext {\n    private Map&lt;String,Object&gt; ioc = new HashMap&lt;String, Object&gt;();\n    public ClassPathXmlApplicationContext(String path){\n        try {\n            SAXReader reader = new SAXReader();\n            Document document = reader.read(\"./src/main/resources/\"+path);\n            Element root = document.getRootElement();\n            Iterator&lt;Element&gt; iterator = root.elementIterator();\n            while(iterator.hasNext()){\n                Element element = iterator.next();\n                String id = element.attributeValue(\"id\");\n                String className = element.attributeValue(\"class\");\n                //通过反射机制创建对象\n                Class clazz = Class.forName(className);\n                //获取无参构造函数，创建目标对象\n                Constructor constructor = clazz.getConstructor();\n                Object object = constructor.newInstance();\n                //给目标对象赋值\n                Iterator&lt;Element&gt; beanIter = element.elementIterator();\n                while(beanIter.hasNext()){\n                    Element property = beanIter.next();\n                    String name = property.attributeValue(\"name\");\n                    String valueStr = property.attributeValue(\"value\");\n                    String ref = property.attributeValue(\"ref\");\n                    if(ref == null){\n                        String methodName = \"set\"+name.substring(0,1).toUpperCase()+name.substring(1);\n                        Field field = clazz.getDeclaredField(name);\n                        Method method = clazz.getDeclaredMethod(methodName,field.getType());\n                        //根据成员变量的数据类型将 value 进行转换\n                        Object value = null;\n                        if(field.getType().getName() == \"long\"){\n                            value = Long.parseLong(valueStr);\n                        }\n                        if(field.getType().getName() == \"java.lang.String\"){\n                            value = valueStr;\n                        }\n                        if(field.getType().getName() == \"int\"){\n                            value = Integer.parseInt(valueStr);\n                        }\n                        method.invoke(object,value);\n                    }\n                    ioc.put(id,object);\n                }\n            }\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e){\n            e.printStackTrace();\n        } catch (NoSuchMethodException e){\n            e.printStackTrace();\n        } catch (InstantiationException e){\n            e.printStackTrace();\n        } catch (IllegalAccessException e){\n            e.printStackTrace();\n        } catch (InvocationTargetException e){\n            e.printStackTrace();\n        } catch (NoSuchFieldException e){\n            e.printStackTrace();\n        }\n    }\n\n    public Object getBean(String id) {\n        return ioc.get(id);\n    }\n}\n</code></pre>\n<h3 id=\"bean\">通过运行时类获取 bean</h3>\n<pre><code class=\"java language-java\">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring.xml\");\nStudent student = (Student) applicationContext.getBean(Student.class);\nSystem.out.println(student);\n</code></pre>\n<p>这种方式存在一个问题，配置文件中一个数据类型的对象只能有一个实例，否则会抛出异常，因为没有唯一的 bean。</p>\n<h3 id=\"bean-1\">通过有参构造创建 bean</h3>\n<ul>\n<li>在实体类中创建对应的有参构造函数。</li>\n<li>配置文件</li>\n</ul>\n<pre><code class=\"xml language-xml\">&lt;bean id=\"student3\" class=\"com.southwind.entity.Student\"&gt;\n    &lt;constructor-arg name=\"id\" value=\"3\"&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg name=\"name\" value=\"小明\"&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg name=\"address\" ref=\"address\"&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<pre><code class=\"xml language-xml\">&lt;bean id=\"student3\" class=\"com.southwind.entity.Student\"&gt;\n    &lt;constructor-arg index=\"0\" value=\"3\"&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=\"2\" value=\"18\"&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=\"1\" value=\"小明\"&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=\"3\" ref=\"address\"&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<h3 id=\"bean-2\">给 bean 注入集合</h3>\n<pre><code class=\"xml language-xml\">&lt;bean id=\"student\" class=\"com.southwind.entity.Student\"&gt;\n    &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt;\n    &lt;property name=\"age\" value=\"33\"&gt;&lt;/property&gt;\n    &lt;property name=\"addresses\"&gt;\n        &lt;list&gt;\n            &lt;ref bean=\"address\"&gt;&lt;/ref&gt;\n            &lt;ref bean=\"address2\"&gt;&lt;/ref&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"address\" class=\"com.southwind.entity.Address\"&gt;\n    &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"科技路\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"address2\" class=\"com.southwind.entity.Address\"&gt;\n    &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"高新区\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<h3 id=\"scope\">scope 作用域</h3>\n<p>默认是单例模式，及创造的对象来自同一块地址，改为prototype，则输出false</p>\n<pre><code class=\"java language-java\">Student student = (Student) applicationContext.getBean(Student.class);\nStudent student1 = (Student) applicationContext.getBean(Student.class);\nsout(student==student1)  //true\n</code></pre>\n<p>Spring 管理的 bean 是根据 scope 来生成的，表示 bean 的作用域，共4种，默认值是 singleton。</p>\n<ul>\n<li>singleton：单例，表示通过 IoC 容器获取的 bean 是唯一的。</li>\n<li>prototype：原型，表示通过 IoC 容器获取的 bean 是不同的。</li>\n<li>request：请求，表示在一次 HTTP 请求内有效。</li>\n<li>session：回话，表示在一个用户会话内有效。</li>\n</ul>\n<p>request 和 session 只适用于 Web 项目，大多数情况下，使用单例和原型较多。</p>\n<p>prototype 模式当业务代码获取 IoC 容器中的 bean 时，Spring 才去调用无参构造创建对应的 bean。</p>\n<p>singleton 模式无论业务代码是否获取 IoC 容器中的 bean，Spring 在加载 spring.xml 时就会创建 bean。</p>\n<h3 id=\"spring\">Spring 的继承</h3>\n<p>与 Java 的继承不同，Java 是类层面的继承，子类可以继承父类的内部结构信息；Spring 是对象层面的继承，子对象可以继承父对象的属性值。</p>\n<pre><code class=\"xml language-xml\">&lt;bean id=\"student2\" class=\"com.southwind.entity.Student\"&gt;\n    &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n    &lt;property name=\"age\" value=\"22\"&gt;&lt;/property&gt;\n    &lt;property name=\"addresses\"&gt;\n        &lt;list&gt;\n            &lt;ref bean=\"address\"&gt;&lt;/ref&gt;\n            &lt;ref bean=\"address2\"&gt;&lt;/ref&gt;\n        &lt;/list&gt;\n    &lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"address\" class=\"com.southwind.entity.Address\"&gt;\n    &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"科技路\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"address2\" class=\"com.southwind.entity.Address\"&gt;\n    &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"高新区\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"stu\" class=\"com.southwind.entity.Student\" parent=\"student2\"&gt;\n    &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>Spring 的继承关注点在于具体的对象，而不在于类，即不同的两个类的实例化对象可以完成继承，前提是子对象必须包含父对象的所有属性，同时可以在此基础上添加其他的属性。</p>\n<h3 id=\"spring-1\">Spring 的依赖</h3>\n<p>与继承类似，依赖也是描述 bean 和 bean 之间的一种关系，配置依赖之后，被依赖的 bean 一定先创建，再创建依赖的 bean，A 依赖于 B，先创建 B，再创建 A。</p>\n<pre><code class=\"xml language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n                           \"&gt;\n\n    &lt;bean id=\"student\" class=\"com.southwind.entity.Student\" depends-on=\"user\"&gt;&lt;/bean&gt;\n\n    &lt;bean id=\"user\" class=\"com.southwind.entity.User\"&gt;&lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"springp\">Spring 的 p 命名空间</h3>\n<p>p 命名空间是对 IoC / DI 的简化操作，使用 p 命名空间可以更加方便的完成 bean 的配置以及 bean 之间的依赖注入。</p>\n<pre><code class=\"xml language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\"&gt;\n\n    &lt;bean id=\"student\" class=\"com.southwind.entity.Student\" p:id=\"1\" p:name=\"张三\" p:age=\"22\" p:address-ref=\"address\"&gt;&lt;/bean&gt;\n\n    &lt;bean id=\"address\" class=\"com.southwind.entity.Address\" p:id=\"2\" p:name=\"科技路\"&gt;&lt;/bean&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<h3 id=\"spring-2\">Spring 的工厂方法</h3>\n<p>为什么会有外部bean注入，因为有的实例可能没办法new，可能new方法完全私有，但又想注册到ioc容器</p>\n<p>IoC 通过工厂模式创建 bean 的方式有两种：</p>\n<ul>\n<li>静态工厂方法</li>\n<li>实例工厂方法</li>\n</ul>\n<blockquote>\n  <p>静态工厂方法</p>\n</blockquote>\n<pre><code class=\"java language-java\">package com.southwind.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Car {\n    private long id;\n    private String name;\n}\n</code></pre>\n<pre><code class=\"java language-java\">package com.thciwei.factory;\n\nimport com.southwind.entity.Car;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class StaticCarFactory {\n    private static Map&lt;Long, Car&gt; carMap;\n    static{\n        carMap = new HashMap&lt;Long, Car&gt;();\n        carMap.put(1L,new Car(1L,\"宝马\"));\n        carMap.put(2L,new Car(2L,\"奔驰\"));\n    }\n\n    public static Car getCar(long id){\n        return carMap.get(id);\n    }\n}\n</code></pre>\n<pre><code class=\"xml language-xml\">&lt;!-- 配置静态工厂创建 Car --&gt;\n&lt;bean id=\"car\" class=\"com.southwind.factory.StaticCarFactory\" factory-method=\"getCar\"&gt;\n    &lt;constructor-arg value=\"2\"&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<blockquote>\n  <p>实例工厂方法</p>\n</blockquote>\n<pre><code class=\"java language-java\">package com.thciwei.factory;\n\nimport com.southwind.entity.Car;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class InstanceCarFactory {\n    private Map&lt;Long, Car&gt; carMap;\n    public InstanceCarFactory(){\n        carMap = new HashMap&lt;Long, Car&gt;();\n        carMap.put(1L,new Car(1L,\"宝马\"));\n        carMap.put(2L,new Car(2L,\"奔驰\"));\n    }\n\n    public Car getCar(long id){\n        return carMap.get(id);\n    }\n}\n</code></pre>\n<pre><code class=\"xml language-xml\">&lt;!-- 配置实例工厂 bean --&gt;\n&lt;bean id=\"carFactory\" class=\"com.southwind.factory.InstanceCarFactory\"&gt;&lt;/bean&gt;\n\n&lt;!-- 赔偿实例工厂创建 Car --&gt;\n&lt;bean id=\"car2\" factory-bean=\"carFactory\" factory-method=\"getCar\"&gt;\n    &lt;constructor-arg value=\"1\"&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<h3 id=\"iocautowire\">IoC 自动装载（Autowire）</h3>\n<p>IoC 负责创建对象，DI 负责完成对象的依赖注入，通过配置 property 标签的 ref 属性来完成，同时 Spring 提供了另外一种更加简便的依赖注入方式：自动装载，不需要手动配置 property，IoC 容器会自动选择 bean 完成注入。</p>\n<p>自动装载有两种方式：</p>\n<ul>\n<li>byName：通过属性名自动装载</li>\n<li>byType：通过属性的数据类型自动装载</li>\n</ul>\n<blockquote>\n  <p>byName</p>\n</blockquote>\n<pre><code class=\"xml language-xml\">&lt;bean id=\"cars\" class=\"com.southwind.entity.Car\"&gt;\n    &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"宝马\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"person\" class=\"com.southwind.entity.Person\" autowire=\"byName\"&gt;\n    &lt;property name=\"id\" value=\"11\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<blockquote>\n  <p>byType</p>\n</blockquote>\n<pre><code class=\"xml language-xml\">&lt;bean id=\"car\" class=\"com.southwind.entity.Car\"&gt;\n    &lt;property name=\"id\" value=\"2\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"奔驰\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"person\" class=\"com.southwind.entity.Person\" autowire=\"byType\"&gt;\n    &lt;property name=\"id\" value=\"11\"&gt;&lt;/property&gt;\n    &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>byType 需要注意，如果同时存在两个及以上的符合条件的 bean 时，自动装载会抛出异常。</p>\n<h3 id=\"-1\">注解</h3>\n<p>service其实是为了批量注册bean</p>\n<h3 id=\"aop\">AOP</h3>\n<p>AOP：Aspect Oriented Programming 面向切面编程。</p>\n<p>AOP 的优点：</p>\n<ul>\n<li>降低模块之间的耦合度。</li>\n<li>使系统更容易扩展。</li>\n<li>更好的代码复用。</li>\n<li>非业务代码更加集中，不分散，便于统一管理。</li>\n<li>业务代码更加简洁存粹，不参杂其他代码的影响。</li>\n</ul>\n<p>AOP 是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面对象，对该切面对象进行编程就是 AOP。</p>\n<h3 id=\"-2\">如何使用？</h3>\n<ul>\n<li>创建 Maven 工程，pom.xml 添加</li>\n</ul>\n<pre><code class=\"xml language-xml\">&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;\n        &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;\n        &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;\n        &lt;version&gt;5.0.11.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre>\n<ul>\n<li>创建一个计算器接口 Cal，定义4个方法。</li>\n</ul>\n<pre><code class=\"java language-java\">package com.thciwei.utils;\n\npublic interface Cal {\n    public int add(int num1,int num2);\n    public int sub(int num1,int num2);\n    public int mul(int num1,int num2);\n    public int div(int num1,int num2);\n}\n</code></pre>\n<ul>\n<li>创建接口的实现类 CalImpl。</li>\n</ul>\n<pre><code class=\"java language-java\">package com.thciwei.utils.impl;\n\nimport com.southwind.utils.Cal;\n\npublic class CalImpl implements Cal {\n    public int add(int num1, int num2) {\n        System.out.println(\"add方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1+num2;\n        System.out.println(\"add方法的结果是\"+result);\n        return result;\n    }\n\n    public int sub(int num1, int num2) {\n        System.out.println(\"sub方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1-num2;\n        System.out.println(\"sub方法的结果是\"+result);\n        return result;\n    }\n\n    public int mul(int num1, int num2) {\n        System.out.println(\"mul方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1*num2;\n        System.out.println(\"mul方法的结果是\"+result);\n        return result;\n    }\n\n    public int div(int num1, int num2) {\n        System.out.println(\"div方法的参数是[\"+num1+\",\"+num2+\"]\");\n        int result = num1/num2;\n        System.out.println(\"div方法的结果是\"+result);\n        return result;\n    }\n}\n</code></pre>\n<p>上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用 AOP 可以进行优化，如何来实现 AOP？使用动态代理的方式来实现。</p>\n<p>给业务代码找一个代理，打印日志信息的工作交个代理来做，这样的话业务代码就只需要关注自身的业务即可。</p>\n<pre><code class=\"java language-java\">package com.thciwei.utils;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\n\npublic class MyInvocationHandler implements InvocationHandler {\n    //接收委托对象\n    private Object object = null;\n\n    //返回代理对象\n    public Object bind(Object object){\n        this.object = object;\n        return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);\n    }\n\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(method.getName()+\"方法的参数是：\"+ Arrays.toString(args));\n        Object result = method.invoke(this.object,args);\n        System.out.println(method.getName()+\"的结果是\"+result);\n        return result;\n    }\n}\n</code></pre>\n<p>以上是通过动态代理实现 AOP 的过程，比较复杂，不好理解，Spring 框架对 AOP 进行了封装，使用 Spring 框架可以用面向对象的思想来实现 AOP。</p>\n<p>Spring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成即可，Spring 框架底层会自动根据切面类以及目标类生成一个代理对象。</p>\n<p>LoggerAspect</p>\n<pre><code class=\"java language-java\">package com.thciwei.aop;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Arrays;\n\n@Aspect\n@Component\npublic class LoggerAspect {\n\n    @Before(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\")\n    public void before(JoinPoint joinPoint){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        //获取参数\n        String args = Arrays.toString(joinPoint.getArgs());\n        System.out.println(name+\"方法的参数是：\"+ args);\n    }\n\n    @After(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\")\n    public void after(JoinPoint joinPoint){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        System.out.println(name+\"方法执行完毕\");\n    }\n\n    @AfterReturning(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\",returning = \"result\")\n    public void afterReturning(JoinPoint joinPoint,Object result){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        System.out.println(name+\"方法的结果是\"+result);\n    }\n\n    @AfterThrowing(value = \"execution(public int com.southwind.utils.impl.CalImpl.*(..))\",throwing = \"exception\")\n    public void afterThrowing(JoinPoint joinPoint,Exception exception){\n        //获取方法名\n        String name = joinPoint.getSignature().getName();\n        System.out.println(name+\"方法抛出异常：\"+exception);\n    }\n\n}\n</code></pre>\n<p>LoggerAspect 类定义处添加的两个注解：</p>\n<ul>\n<li><code>@Aspect</code>：表示该类是切面类。</li>\n<li><code>@Component</code>：将该类的对象注入到 IoC 容器。</li>\n</ul>\n<p>具体方法处添加的注解：</p>\n<p><code>@Before</code>：表示方法执行的具体位置和时机。</p>\n<p>CalImpl 也需要添加 <code>@Component</code>，交给 IoC 容器来管理。</p>\n<pre><code class=\"java language-java\">package com.thciwei.utils.impl;\n\nimport com.southwind.utils.Cal;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CalImpl implements Cal {\n    public int add(int num1, int num2) {\n        int result = num1+num2;\n        return result;\n    }\n\n    public int sub(int num1, int num2) {\n        int result = num1-num2;\n        return result;\n    }\n\n    public int mul(int num1, int num2) {\n        int result = num1*num2;\n        return result;\n    }\n\n    public int div(int num1, int num2) {\n        int result = num1/num2;\n        return result;\n    }\n}\n</code></pre>\n<p>xxxxxxxxxx&nbsp;create index idx_email using hash on student(email)sql</p>\n<pre><code class=\"xml language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd\n    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\n\"&gt;\n\n    &lt;!-- 自动扫描 --&gt;\n    &lt;context:component-scan base-package=\"com.southwind\"&gt;&lt;/context:component-scan&gt;\n\n    &lt;!-- 是Aspect注解生效，为目标类自动生成代理对象 --&gt;\n    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;\n\n&lt;/beans&gt;\n</code></pre>\n<p><code>context:component-scan</code> 将 <code>com.southwind</code> 包中的所有类进行扫描，如果该类同时添加了 <code>@Component</code>，则将该类扫描到 IoC 容器中，即 IoC 管理它的对象。</p>\n<p><code>aop:aspectj-autoproxy</code> 让 Spring 框架结合切面类和目标类自动生成动态代理对象。</p>\n<ul>\n<li>切面：横切关注点被模块化的抽象对象。</li>\n<li>通知：切面对象完成的工作。</li>\n<li>目标：被通知的对象，即被横切的对象。</li>\n<li>代理：切面、通知、目标混合之后的对象。</li>\n<li>连接点：通知要插入业务代码的具体位置。</li>\n<li>切点：AOP 通过切点定位到连接点。</li>\n</ul>', 'Spring框架的核心机制，IOC和AOP', 'http://gulimall-wqs.oss-cn-beijing.aliyuncs.com/typora/202301211429489.png', '2023-05-03 17:42:57', 1, 1, 3672, 0);

-- ----------------------------
-- Table structure for article_category
-- ----------------------------
DROP TABLE IF EXISTS `article_category`;
CREATE TABLE `article_category`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `aid` int(11) NULL DEFAULT NULL COMMENT '博客id',
  `cid` int(11) NULL DEFAULT NULL COMMENT '分类id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 36 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博客所在的分类' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_category
-- ----------------------------
INSERT INTO `article_category` VALUES (1, 1, 3);
INSERT INTO `article_category` VALUES (2, 2, 2);
INSERT INTO `article_category` VALUES (3, 3, 1);
INSERT INTO `article_category` VALUES (5, 7, 4);
INSERT INTO `article_category` VALUES (17, 19, 5);
INSERT INTO `article_category` VALUES (18, 20, 2);
INSERT INTO `article_category` VALUES (19, 21, 2);
INSERT INTO `article_category` VALUES (20, 22, 3);
INSERT INTO `article_category` VALUES (22, 24, 2);
INSERT INTO `article_category` VALUES (23, 25, 2);
INSERT INTO `article_category` VALUES (24, 26, 4);
INSERT INTO `article_category` VALUES (25, 27, 1);
INSERT INTO `article_category` VALUES (26, 28, 2);
INSERT INTO `article_category` VALUES (27, 29, 2);
INSERT INTO `article_category` VALUES (28, 30, 1);
INSERT INTO `article_category` VALUES (29, 31, 2);
INSERT INTO `article_category` VALUES (30, 32, 2);
INSERT INTO `article_category` VALUES (31, 33, 4);
INSERT INTO `article_category` VALUES (32, 34, 8);
INSERT INTO `article_category` VALUES (33, 35, 5);
INSERT INTO `article_category` VALUES (34, 36, 8);
INSERT INTO `article_category` VALUES (35, 37, 2);

-- ----------------------------
-- Table structure for article_tags
-- ----------------------------
DROP TABLE IF EXISTS `article_tags`;
CREATE TABLE `article_tags`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `aid` int(11) NULL DEFAULT NULL COMMENT '博客id',
  `tid` int(11) NULL DEFAULT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 36 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博客和标签的对应关系' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_tags
-- ----------------------------
INSERT INTO `article_tags` VALUES (1, 1, 1);
INSERT INTO `article_tags` VALUES (2, 2, 2);
INSERT INTO `article_tags` VALUES (3, 3, 3);
INSERT INTO `article_tags` VALUES (5, 7, 1);
INSERT INTO `article_tags` VALUES (17, 19, 3);
INSERT INTO `article_tags` VALUES (18, 20, 1);
INSERT INTO `article_tags` VALUES (19, 21, 2);
INSERT INTO `article_tags` VALUES (20, 22, 1);
INSERT INTO `article_tags` VALUES (22, 24, 2);
INSERT INTO `article_tags` VALUES (23, 25, 3);
INSERT INTO `article_tags` VALUES (24, 26, 3);
INSERT INTO `article_tags` VALUES (25, 27, 3);
INSERT INTO `article_tags` VALUES (26, 28, 3);
INSERT INTO `article_tags` VALUES (27, 29, 3);
INSERT INTO `article_tags` VALUES (28, 30, 3);
INSERT INTO `article_tags` VALUES (29, 31, 3);
INSERT INTO `article_tags` VALUES (30, 32, 3);
INSERT INTO `article_tags` VALUES (31, 33, 2);
INSERT INTO `article_tags` VALUES (32, 34, 4);
INSERT INTO `article_tags` VALUES (33, 35, 7);
INSERT INTO `article_tags` VALUES (34, 36, 4);
INSERT INTO `article_tags` VALUES (35, 37, 3);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '分类id',
  `cateName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类名称',
  `date` datetime(0) NULL DEFAULT NULL COMMENT '创建日期',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '分类属性' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (1, 'Vue', '2021-09-03 11:16:59');
INSERT INTO `category` VALUES (2, 'Java', '2021-08-01 11:17:06');
INSERT INTO `category` VALUES (4, 'Linux', '2021-05-01 11:17:15');
INSERT INTO `category` VALUES (5, 'Docker', '2021-09-03 11:16:59');
INSERT INTO `category` VALUES (8, '数据库', '2023-05-03 16:19:44');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '评论内容',
  `createTime` datetime(0) NULL DEFAULT NULL COMMENT '评论时间',
  `fromUserAvatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论者头像',
  `fromUserId` int(11) NULL DEFAULT NULL COMMENT '评论用户id',
  `fromUserName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论者名字',
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `parentId` int(11) NULL DEFAULT NULL,
  `postId` int(11) NULL DEFAULT NULL COMMENT '文章id',
  `toUserAvatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '被评论者头像',
  `toUserId` int(11) NULL DEFAULT NULL COMMENT '被评论者id',
  `toUserName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '被评论者姓名',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 26 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('最后一句是不是有问题', '2021-09-25 14:17:26', 'https://s1.ax1x.com/2020/05/14/YDhU81.jpg', 1, '崔敏', 1, NULL, 7, 'https://s1.ax1x.com/2020/05/14/YDhBDO.jpg', NULL, 'ciwei');
INSERT INTO `comment` VALUES ('我同意', '2021-09-25 14:19:31', '	https://gitee.com/thciweicloud/tmp/raw/master/ciwei.png', 2, '司马懿', 2, 1, 7, '22', 1, '崔敏');
INSERT INTO `comment` VALUES ('林纳斯gg', '2021-09-25 14:22:06', 'https://s1.ax1x.com/2020/05/14/YDhU81.jpg', NULL, '诸葛亮', 3, NULL, 7, 'https://s1.ax1x.com/2020/05/14/YDhBDO.jpg', NULL, 'ciwei');
INSERT INTO `comment` VALUES ('linux and unix', '2021-09-25 22:59:39', '', 5, '尤大', 5, NULL, 7, '', NULL, 'ciwei');
INSERT INTO `comment` VALUES ('顶<img data-v-7c9572d1=\"\" width=\"20\" height=\"20\" src=\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzNiAzNiI+PHBhdGggZmlsbD0iI0ZGREM1RCIgZD0iTTUgMjFjMCAyLjIwOS0xLjExOSA0LTIuNSA0UzAgMjMuMjA5IDAgMjFzMS4xMTktNCAyLjUtNFM1IDE4Ljc5MSA1IDIxeiIvPjxwYXRoIGZpbGw9IiNGRkRDNUQiIGQ9Ik0zIDE4LjU2MkMzIDEwLjAzNyA4LjM3MyAzLjEyNSAxNSAzLjEyNXMxMiA2LjkxMiAxMiAxNS40MzhDMjcgMjcuMDg4IDIxLjYyNyAzNCAxNSAzNFMzIDI3LjA4OCAzIDE4LjU2MnoiLz48cGF0aCBmaWxsPSIjREQyRTQ0IiBkPSJNMjAgMGMtLjI0OSAwLS40NzguMDA3LS43MTMuMDEyQzE5LjE5LjAxIDE5LjA5NyAwIDE5IDAgOSAwIDIgNC41ODIgMiA5czYuMzczIDQgMTMgNGM0LjQ0MiAwIDcuNjQ4IDAgOS45NjYtLjA4NkwyNSAxM2w2IDE1aDJzLjM0My0zLjA1NSAxLTdjMS02IC41MzMtMjEtMTQtMjF6Ii8+PHBhdGggZmlsbD0iI0ZGREM1RCIgZD0iTTMwIDIxYzAgMi4yMDktMS4xMTkgNC0yLjUgNFMyNSAyMy4yMDkgMjUgMjFzMS4xMTktNCAyLjUtNCAyLjUgMS43OTEgMi41IDR6Ii8+PHBhdGggZmlsbD0iIzY2MjExMyIgZD0iTTEwIDIxYy0uNTUyIDAtMS0uNDQ3LTEtMXYtMmMwLS41NTIuNDQ4LTEgMS0xczEgLjQ0OCAxIDF2MmMwIC41NTMtLjQ0OCAxLTEgMXptMTAgMGMtLjU1MyAwLTEtLjQ0Ny0xLTF2LTJjMC0uNTUyLjQ0Ny0xIDEtMXMxIC40NDggMSAxdjJjMCAuNTUzLS40NDcgMS0xIDF6Ii8+PHBhdGggZmlsbD0iI0I3NzU1RSIgZD0iTTE2IDI2aC0yYy0uNTUyIDAtMS0uNDQ3LTEtMXMuNDQ4LTEgMS0xaDJjLjU1MiAwIDEgLjQ0NyAxIDFzLS40NDggMS0xIDF6Ii8+PHBhdGggZmlsbD0iI0U2RTdFOCIgZD0iTTI3IDI1YzAtMi0yLjI5My0uNzA3LTMgMC0xIDEtMyAzLTUgMi0yLjgyOC0xLjQxNC00LTEtNC0xcy0xLjE3MS0uNDE0LTQgMWMtMiAxLTQtMS01LTItLjcwNy0uNzA3LTMtMi0zIDBzMSAyIDEgMmMtMSAyIDEgMyAxIDMgMCAzIDMgMyAzIDMgMCAzIDQgMiA0IDIgMSAxIDMgMSAzIDFzMiAwIDMtMWMwIDAgNCAxIDQtMiAwIDAgMyAwIDMtMyAwIDAgMi0xIDEtMyAwIDAgMSAwIDEtMnoiLz48cGF0aCBmaWxsPSIjRkZEQzVEIiBkPSJNMTUgMjhjNyAwIDQgMiAwIDJzLTctMiAwLTJ6Ii8+PGVsbGlwc2UgZmlsbD0iI0QxRDNENCIgY3g9IjMiIGN5PSIxNCIgcng9IjIiIHJ5PSI0Ii8+PGVsbGlwc2UgZmlsbD0iI0QxRDNENCIgY3g9IjI2IiBjeT0iMTQiIHJ4PSIyIiByeT0iNCIvPjxjaXJjbGUgZmlsbD0iI0YxRjJGMiIgY3g9IjMyIiBjeT0iMjkiIHI9IjQiLz48cGF0aCBmaWxsPSIjRjFGMkYyIiBkPSJNMjkgMTJjMCAxLjEwNC0uODk2IDItMiAySDJjLTEuMTA0IDAtMi0uODk2LTItMnYtMWMwLTEuMTA0Ljg5Ni0yIDItMmgyNWMxLjEwNCAwIDIgLjg5NiAyIDJ2MXoiLz48L3N2Zz4=\" alt=\"\" class=\"emoji-icon\" style=\"vertical-align: text-top;\">', '2021-09-25 23:27:16', '', 6, '尤小又', 6, 5, 7, '', 5, '尤大');
INSERT INTO `comment` VALUES ('可以呀兄弟', '2021-09-25 23:32:37', '', NULL, '大和', 7, 5, 7, '', 5, '尤大');
INSERT INTO `comment` VALUES ('成功了', '2021-09-25 23:34:15', '', NULL, '尤大', 8, NULL, 7, '', NULL, 'ciwei');
INSERT INTO `comment` VALUES ('恭喜', '2021-09-25 23:35:59', '', NULL, '尤小又', 10, NULL, 7, '', NULL, '尤大');
INSERT INTO `comment` VALUES ('ttk', '2021-10-22 13:15:55', 'https://portrait.gitee.com/uploads/avatars/user/2579/7739504_thciweicloud_1621301627.png', 7739504, 'thciweicloud', 25, NULL, 3, '', NULL, '');

-- ----------------------------
-- Table structure for info
-- ----------------------------
DROP TABLE IF EXISTS `info`;
CREATE TABLE `info`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `mail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '内容',
  `isView` tinyint(4) NULL DEFAULT 0 COMMENT '是否读消息【0-未读1-已读】',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '友链邮箱和信息' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of info
-- ----------------------------
INSERT INTO `info` VALUES (1, '1462108765@qq.com', '站点:被追忆的风，url:www.feng.com;介绍:后端知识分享站点', 1);
INSERT INTO `info` VALUES (2, '23457213@qq.com', '33', 1);
INSERT INTO `info` VALUES (3, '123132225@qq.com', '444', 0);
INSERT INTO `info` VALUES (4, '1462106316@qq.com', '111111111111111', 1);
INSERT INTO `info` VALUES (5, '2474478383@qq.com', 'asd', 1);
INSERT INTO `info` VALUES (6, '2474478383@qq.com', '你好我想要加入此站点，http://locsss.com', 1);
INSERT INTO `info` VALUES (7, '1462106316@qq.com', '你好啊我想加入', 0);

-- ----------------------------
-- Table structure for mail_send_log
-- ----------------------------
DROP TABLE IF EXISTS `mail_send_log`;
CREATE TABLE `mail_send_log`  (
  `msgId` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `websiteId` int(11) NULL DEFAULT NULL,
  `status` int(11) NOT NULL DEFAULT 0 COMMENT '0发送中，1发送成功，2发送失败',
  `routeKey` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '绑定key',
  `exchange` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '交换机',
  `count` int(11) UNSIGNED NOT NULL DEFAULT 0 COMMENT '重试次数',
  `tryTime` date NULL DEFAULT NULL COMMENT '第一次重试时间',
  `createTime` date NULL DEFAULT NULL,
  `updateTime` date NULL DEFAULT NULL
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '邮件发送保证消息可靠性' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of mail_send_log
-- ----------------------------
INSERT INTO `mail_send_log` VALUES ('31c740f6-3394-4518-8dc0-5b66321d2538', 48, 2, 'thciwei.mail.routing.key', 'thciwei.mail.exchange', 3, '2022-12-31', '2022-12-31', '2022-12-31');
INSERT INTO `mail_send_log` VALUES ('7dbebbf2-e782-41fa-8cc1-e961a9b64215', 49, 2, 'thciwei.mail.routing.key', 'thciwei.mail.exchange', 3, '2023-05-02', '2023-05-02', '2023-05-02');

-- ----------------------------
-- Table structure for tags
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '标签id',
  `tagName` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标签名称',
  `date` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '标签属性' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tags
-- ----------------------------
INSERT INTO `tags` VALUES (2, 'git', '2021-09-04 11:18:22');
INSERT INTO `tags` VALUES (3, 'Spring', '2021-09-05 11:18:24');
INSERT INTO `tags` VALUES (4, 'MySQL', '2022-09-05 11:18:24');
INSERT INTO `tags` VALUES (5, 'Elasticsearch', '2022-09-05 11:18:24');
INSERT INTO `tags` VALUES (6, 'Redis', '2022-10-05 11:18:24');
INSERT INTO `tags` VALUES (7, '容器化', '2022-11-04 13:18:22');

-- ----------------------------
-- Table structure for todoList
-- ----------------------------
DROP TABLE IF EXISTS `todoList`;
CREATE TABLE `todoList`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `text` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'todo事件',
  `done` tinyint(4) NULL DEFAULT 0 COMMENT '是否完成',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '事件清单' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of todoList
-- ----------------------------
INSERT INTO `todoList` VALUES (1, '完成爬虫模块', 0);
INSERT INTO `todoList` VALUES (2, '整合oss', 0);
INSERT INTO `todoList` VALUES (3, '完成search服务', 0);
INSERT INTO `todoList` VALUES (4, '接入zipkin', 0);

-- ----------------------------
-- Table structure for user_auth
-- ----------------------------
DROP TABLE IF EXISTS `user_auth`;
CREATE TABLE `user_auth`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '密码',
  `nickname` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `mobile` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '手机号码',
  `header` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `gender` tinyint(4) NULL DEFAULT NULL COMMENT '性别【1-男0-女】',
  `birthday` date NULL DEFAULT NULL COMMENT '生日',
  `city` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '城市',
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `sign` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '个性签名',
  `source_type` tinyint(4) NULL DEFAULT NULL COMMENT '用户来源',
  `state` tinyint(4) NOT NULL DEFAULT 0 COMMENT '启用状态【0-存在1-不存在】',
  `create_time` date NULL DEFAULT NULL COMMENT '注册时间',
  `social_uid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '社交账号ID',
  `access_token` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '社交账号Token',
  `expires_in` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '社交账号Token过期时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user_auth
-- ----------------------------
INSERT INTO `user_auth` VALUES (16, NULL, NULL, '\"thciweicloud\"', NULL, '\"https://foruda.gitee.com/avatar/1677093610812256372/7739504_thciweicloud_1638799678.png\"', NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, '7739504', 'fe8d584d5c7b3e40c6242f186894bf22', '86400');

-- ----------------------------
-- Table structure for websiteInfo
-- ----------------------------
DROP TABLE IF EXISTS `websiteInfo`;
CREATE TABLE `websiteInfo`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '友链名称',
  `link` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '友链path',
  `descp` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '站点描述',
  `mail` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '友站邮箱',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 50 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '友链接' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of websiteInfo
-- ----------------------------
INSERT INTO `websiteInfo` VALUES (1, '风雪之隅 \r\n', 'http://www.laruence.com/\n', '  PHP核心开发人员', '1472106316@qq.com');
INSERT INTO `websiteInfo` VALUES (2, '蘑菇博客', 'http://demoweb.moguit.cn/', '陌溪大佬开发', '2422106316@qq.com');
INSERT INTO `websiteInfo` VALUES (3, '闪烁之狐', 'https://github.com/blinkfox', 'hexo知名主题开发者', '3442106316@qq.com');
INSERT INTO `websiteInfo` VALUES (4, '浸水止渴', 'http://thciweicloud.gitee.io/thciwei/', '我的Learning Notes', '1462106316@qq.com');
INSERT INTO `websiteInfo` VALUES (20, '江南一点雨', 'http://www.javaboy.org/', '松哥java专家', '3694478989@qq.com');
INSERT INTO `websiteInfo` VALUES (23, 'kang', 'https://blog.kangkang.org/', '人称康神', '7734479083@qq.com');
INSERT INTO `websiteInfo` VALUES (24, '心灵港', 'https://qinjiangbo.com/thoughts-in-software-engineering.html', '技术分享', '2471449383@qq.com');
INSERT INTO `websiteInfo` VALUES (25, 'Wing的小站', 'https://www.wingmei.cn/', '个人小站', '2367478383@qq.com');
INSERT INTO `websiteInfo` VALUES (26, '帅地', 'https://www.iamshuaidi.com/', '知名面试博主', '7364478383@qq.com');
INSERT INTO `websiteInfo` VALUES (49, '测试站点', 'www.test.com', 'test', '2474478383@qq.com');

SET FOREIGN_KEY_CHECKS = 1;
